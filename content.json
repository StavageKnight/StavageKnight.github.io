{"meta":{"title":"Stavage","subtitle":"","description":"My personal blog","author":"Stavage","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-08","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-08","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"11-08","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"11-08","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-08","excerpt":""}],"posts":[{"title":"软件测试","text":"一.软件测试的分类1.按测试阶段或测试步骤划分： 单元测试，集成测试，验收测试（Alpha测试，Beta测试），系统测试。这种划分来自于软件的开发过程，目的是验证软件开发过程各阶段的工作是否符合需求和设计要求 单元测试 在软件单元完成编码后，首先进行单元测试，验证软件单元是否正确实现了规定的功能和接口等要求 集成测试 在确认没有问题后，将软件单元组装在一起，进行集成测试，验证软件是否满足设计需求 验收测试（有效性，合格性） 验收测试又称为有效性或合格性测试，其目的是验证软件的功能和性能及其特性是否与客户的要求一致，是否满足软件需求规格说明书的规定。按照测试的方法又有Alpha测试和Beta测试 Alpha测试：在开发方的场所，用户在开发人员的指导下对软件进行测试 ，测试是受控的，开发人员负责记录错误和使用中出现的问题 Beta测试：测试是由软件的最终用户在一个或多个用户场所来进行，开发人员通常不在现场，整个测试不被控制，用户记录下所有的问题，并报告给开发人员 系统测试：最后使通过确认测试的软件与其他系统成分（计算机硬件及相关的外围设备、数据采集和传输机构，支持软件）组合在一起，并使其在实际运行环境中运行，进行系统测试 2.按测试对象划分： 单元测试，配置测试，系统测试 3.按测试技术划分： 静态测试，动态测试（白盒测试【覆盖测试，域测试，程序变异测试，路径测试，符号测试】，黑盒测试【功能测试，强度测试，边界测试，随机测试】） 二.软件缺陷管理软件缺陷常常又被叫做BUG，所谓软件缺陷，即为计算机软件或程序中存在的某种破坏正常运行能力的问题、错误或者隐藏的功能缺陷。缺陷的存在会导致软件产品在某种程度上不能满足用户的需要。 IEEE729-1983对缺陷有一个标准的定义： · 从产品内部看，缺陷是软件产品开发或维护过程中存在的错误、毛病等各种问题 · 从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背 缺陷的等级分类致命错误：不能执行正常工作或重要功能、导致系统奔溃或资源严重不足、造成数据丢失 严重错误：严重影响系统要求或基本功能实现、且不存在可代替的解决办法或方式 一般错误：影响要求或系统功能实现，但存在可代替的方法或方式 轻微错误：操作不便或遇到麻烦，但不影响执行工作或使用重要功能 软件缺陷的属性缺陷标识：标记某个缺陷的一组符号，每个缺陷必须有一个唯一的标识 缺陷类型：根据缺陷的自然属性划分的缺陷种类 缺陷严重程度：指因缺陷引起的故障对软件产品的影响程度 缺陷优先级：指缺陷必须被修复的紧急程度 缺陷状态：指缺陷通过一个跟踪修复过程的进展情况 缺陷起源：指缺陷引起的故障或事件第一次被检测到的阶段 缺陷来源：指引起缺陷的起因 测试充分准则的基本性质 空测试对于任何软件测试都是不充分的 对任何软件都存在有限的充分测试数据集，这一性质称为有限性 如果一个测试数据集对一个软件系统的测试是充分的，那么在增加一些测试用例也是充分的，这一性质称为单调性 软件越复杂，需要的测试用例就越多，这一性质称为复杂性 测试得越多，进一步测试所能得到的充分性增长就越少，这一性质称为回报递减律 在实际工作中，常用的停止测试的标准有五类 三.软件质量和测试相关特性软件质量质量：实体基于其所有特性满足需要的程度 质量定义包含要素：实体+特性集合+需求 软件质量：软件与明确地和隐含地定义的需求相一致的程度 流程，技术，组织是影响软件质量的主要因素 软件质量特性：功能性，可靠性，可使用性，效率，可维护性，可移植性 软件质量活动CMM过程能力等级：1.初始级（不可控），2.可重复级（可以重复以前的过程），3.已定义级（标准化），4.已管理级（定量），5.优化级（改进） 六西格玛（6 Sigma）由摩托罗拉提出，主要强调制定极高的目标、收集数据以及分析结果 六西格玛计算：$(1- \\frac {缺陷数} {1000000}) * 100% $ ——每百万缺陷数 软件质量活动软件质量活动有软件质量保证（SQA）、度量和测试 SQA和测试的关系：SQA从流程方面保证软件的质量，测试从技术方面保证软件的质量，只进行SQA活动或只进行测试活动不一定产生好的软件质量 SQA的工作范围：1.保证制度体系；2.使用过程改进；3.指导项目实施；4.增加透明度；5.评审项目活动；6.审核工作产品；7.协助问题解决；8.提供决策参考；9.进行缺陷预防；10.实现质量目标 度量度量：对事物属性量化表示 软件度量：对软件开发项目、过程及其产品进行数据定义、收集以及分析的持续性定量化过程 度量的作用：理解，预测，评估，改进 测试的复杂性和经济性黑盒测试：测试人员不考虑程序内部结构和内部特性的情况下，只根据需求规格说明书，设计测试用例，检查程序的功能是否按照规范说明的规定正确地执行 白盒测试：允许人们检查其的内部结构 测试的经济性一是体现在测试工作在整个项目开发过程中的重要地位 二是体现在应该按照什么样的原则进行测试，以实现测试成本与测试效果的统一 软件质量保证软件质量保证就是通过对软件产品有计划地进行检查和审计来验证软件是否合乎标准，找到改进的方法，以达到防止产生软件缺陷的目的 软件测试过程及管理软件测试过程： 测试需求的分析和确定 测试计划 测试设计 测试执行 测试记录和缺陷跟踪 回归测试 测试总结报告 测试需求的分类根据使用范围可分为：公共测试需求（同类型系统共同需要的，通用的需求，列为公共测试需求），项目测试需求（根据不同的项目，编制出的针对项目特点的测试需求） 根据需求类别可分为：显性测试需求（即可直接获取的需求，如项目组提供的各类需求文档、会议纪要、用户手册以及项目组主动告知的一些需求），隐形测试需求（无法直接获取的需求，如程序运行中一些必要的条件限制；再如某系统的行业标准、规范中隐含的需求等） 测试计划测试计划：指描述了要进行的测试活动的范围、方法、资源和进度的文档，它确定了测试项、被测特性、测试任务、谁执行任务、各种可能的风险，通常作为关于质量的重要文档呈现给管理层 测试计划的内容：确定测试范围，制定测试策略，确定测试任务，确定测试资源与工作量，进度安排，风险及对策 测试设计 缺陷分析缺陷分类：按严重程度划分（系统奔溃，严重，一般，次要，建议），按优先级划分（高，中，低），按测试种类划分（逻辑功能类，性能类，界面类，易用类，兼容性类） 缺陷分析方法：ODC（正交缺陷分类）分析方法，Gompertz分析法，DRE&#x2F;DRM分析法 四.单元测试单元测试又称模块测试。是针对软件设计的最小单位——程序模块（单元），进行正确性检验的测试工作，其主要内容包括单元的内部结构、单元的功能和可观测行为 单元测试的目标：检查代码实现是否符合描述（依据是详细设计描述），尽早发现错误 单元测试的内容单元测试主要对模块的五个基本特征（模块接口，局部数据结构，边界条件，重要的执行路径，错误处理）进行评价 模块接口：对通过被测模块的数据流进行测试，检查进出模块的数据是否正确 局部数据结构：检查局部数据结构能否保持完整性 边界条件：检查临界数据是否正确处理 重要的执行路径：对模块中的重要的执行路径进行测试。检查由于计算错误，判断错误，控制流错误导致的程序错误 错误处理：检查临界数据是否正确处理 单元测试环境建立驱动模块：被测基本单元的主程序，它接收测试数据，并把数据传送给被测单元，最后输出实测结果 桩模块：用来代替被测基本单元调用的其他基本单元 单元测试策略自顶向下的单元测试 ​ 优点：在集成测试前提供早期的集成途径，在执行上和详细设计的顺序一致，不需要开发驱动模块 ​ 缺点：随着测试的进行，测试过程越来越复杂，开发和维护成本增加 自底向上的单元测试 ​ 优点：在集成测试前提供系统早期的集成途径，不需要开发桩模块 ​ 缺点：随着测试的进行，测试过程越来越复杂 孤立单元测试 ​ 不考虑每个的单元和其他单元之间的关系，为每个单元设计桩模块或驱动模块，每个模块进行独立测试 ​ 优点：简单、容易操作，可达到高的结构覆盖率 ​ 缺点：不提供一种系统早期的集成途径 变异测试定义：变异测试是一种对测试数据集的有效性、充分性进行评估的技术，能为开发人员开展需求设计、单元测试、集成测试提供有效的帮助 工作方式：变异测试通过对比源程序与变异程序在执行同一测试用例时的差异来评价测试用例集的错误检测能力 直接目的：是帮助测试者发现有效测试（数据），或者定位测试数据的弱点，或者定位在执行中很少（或从不）使用代码的弱点 原理：在变异测试中，一般利用与源程序差异极小的简单变异体来模拟程序中可能存在的各种缺陷 变异测试方法可用于度量测试用例缺陷检测能力 变异及变体程序变异：指基于预先定义的变异操作对程序进行修改，进而得到源程序变异体（变异程序）的过程 变异是一种变更程序的行为，即使只是轻微的变更也可以被称为变异。用P表示原始被测程序，M表示轻微变更P后得到的程序，则可以把M称为P的变体，P是M的父体。如果P的语法是正确的，即能够顺利通过编译，则M也一定是语法正确的。M表现出的行为可能和P相同。一般来说，为了达到测试评价的目的，我们进行的变异只是一些比较轻微的变更 仅经过一次变更而得到的变体被称为是一阶变体，二阶变体同理，所以一个n阶变体可以由一个(n-1)阶变体进行一个一阶变更而得到，在实际中，使用最多的还是一阶变体，高于一阶的变体被叫做高阶变体 耦合效应：指若测试用例能杀死简单变异体，则也容易杀死复杂变异体 变异算子在符合语法规则前提下，变异算子定义了从原有程序生成差别极小程序（即变异体）的转换规则 Offutt和King于1987年首次定义了22种变异算子 变异算子的指导准则：语法正确性，典型性，最小性和有效性，精确定义 变异类型根据执行差异不同，可将变异测试分为弱变异测试和强变异测试 若测试用例可以强变异检测到变异体，则一定可以弱变异检测到该变异体，反之则不然 弱变异检测方式的优点是不需要完整执行整个变异体，即一旦相关程序实体被执行后，就立刻可以判断该变异体是否被检测到。但由于不同程序实体间存在依赖关系，对于评估测试用例集充分性来说，弱变异检测方式要弱于强变异检测方式。因此弱变异检测方式通过牺牲变异评分的精确性来提高变异测试分析的效率 变异得分是一种评价测试用例集错误检测有效性的度量指标；其值介于0与1之间，数值越高，表明被杀死的变异程序越多，测试用例集的错误检测能力越强，反之则越低 当$score_{mutaton}$的值为0时，表明测试用例集没有杀死任何一个变异程序；当$score_{mutaton}$的值为1时，表明测试用例集杀死了所有非等价的变异程序 等价变异体：如果对于程序P的输入域中的每一个输入，变异体M的执行结果等于P的执行结果，则认为M等价于P 系统测试系统测试是指测试整个系统以确定其是否能够提供应用的所有需求行为。包括多种测试活动，分为功能性测试和非功能性测试 目的：通过与系统需求定义作比较，发现软件与系统的定义不符合或与之矛盾的地方，对计算机系统做一系列严格测试，保证系统交付给用户之后能正常使用 系统测试是为了发现缺陷并度量产品质量，按照系统的功能和性能需求进行的测试，一般采用黑盒测试技术，由独立的测试人员完成 功能测试方法：链接或界面切换测试，业务流程测试 业务流程测试：基于用例场景设计测试用例 性能测试性能测试主要检验软件是否达到需求规格说明书中规定的各类性能指标，并满足一些性能相关的约束和限制条件 性能测试基准：响应时间，并发用户数，吞吐量 性能测试策略：Flat测试（一次加载所有用户，在预定的时间段内持续运行，取相应时间和吞吐量的平均值），Ramp-up测试（用户是交错上升的，无法产生精确和可重现的平均值，但可以看出随着系统负载的改变，测试值是如何改变的，可以据此确定Flat测试的范围）","path":"2025/04/15/软件测试/","date":"04-15","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"面试","text":"网盘项目采用mysql进行数据存储，redis用于数据缓存（其中包括用户空间，下载信息和邮箱验证码的缓存），使用mybatis实现动态sql，使用pagehelper实现分页查询，在文件上传中支持妙传（通过判断md5值是否存在判断文件是否存在，如果存在直接创建新的文件记录，复用已存在的文件），针对大文件使用分片上传，提高传输速度，同时采用异步合并确保不会阻塞主线程，文件上传完成后立即返回成功","path":"2025/03/30/面试/","date":"03-30","excerpt":"","tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"常用组件","text":"统一返回结果123456789101112131415161718192021222324252627282930313233343536373839package com.example.entity.vo;import lombok.Data;import java.io.Serializable;/** * 后端统一返回结果 * @param &lt;T&gt; */@Datapublic class Result&lt;T&gt; implements Serializable &#123; private Integer code; //编码：1成功，0和其它数字为失败 private String msg; //错误信息 private T data; //数据 public static &lt;T&gt; Result&lt;T&gt; success() &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); result.code = 1; return result; &#125; public static &lt;T&gt; Result&lt;T&gt; success(T object) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); result.data = object; result.code = 1; return result; &#125; public static &lt;T&gt; Result&lt;T&gt; error(String msg) &#123; Result result = new Result(); result.msg = msg; result.code = 0; return result; &#125;&#125; 雪花算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.example.springbootpracticey.Component;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.domain.AuditorAware;import org.springframework.data.jdbc.repository.config.EnableJdbcAuditing;import java.net.NetworkInterface;import java.security.SecureRandom;import java.time.Instant;import java.util.Enumeration;import java.util.Optional;@Configuration@EnableJdbcAuditingpublic class SnowflakeGenerator &#123; @Bean AuditorAware&lt;String&gt; auditorAware() &#123; Snowflake s = new Snowflake(); return () -&gt; Optional.of(String.valueOf(s.nextId())); &#125; private static class Snowflake &#123; private static final int UNUSED_BITS = 1; // Sign bit, Unused (always set to 0) private static final int EPOCH_BITS = 41; private static final int NODE_ID_BITS = 10; private static final int SEQUENCE_BITS = 12; private static final long maxNodeId = (1L &lt;&lt; NODE_ID_BITS) - 1; private static final long maxSequence = (1L &lt;&lt; SEQUENCE_BITS) - 1; // Custom Epoch (January 1, 2015 Midnight UTC = 2015-01-01T00:00:00Z) private static final long DEFAULT_CUSTOM_EPOCH = 1420070400000L; private final long nodeId; private final long customEpoch; private volatile long lastTimestamp = -1L; private volatile long sequence = 0L; // Create Snowflake with a nodeId and custom epoch public Snowflake(long nodeId, long customEpoch) &#123; if(nodeId &lt; 0 || nodeId &gt; maxNodeId) &#123; throw new IllegalArgumentException(String.format(&quot;NodeId must be between %d and %d&quot;, 0, maxNodeId)); &#125; this.nodeId = nodeId; this.customEpoch = customEpoch; &#125; // Create Snowflake with a nodeId public Snowflake(long nodeId) &#123; this(nodeId, DEFAULT_CUSTOM_EPOCH); &#125; // Let Snowflake generate a nodeId public Snowflake() &#123; this.nodeId = createNodeId(); this.customEpoch = DEFAULT_CUSTOM_EPOCH; &#125; public synchronized long nextId() &#123; long currentTimestamp = timestamp(); if(currentTimestamp &lt; lastTimestamp) &#123; throw new IllegalStateException(&quot;Invalid System Clock!&quot;); &#125; if (currentTimestamp == lastTimestamp) &#123; sequence = (sequence + 1) &amp; maxSequence; if(sequence == 0) &#123; // Sequence Exhausted, wait till next millisecond. currentTimestamp = waitNextMillis(currentTimestamp); &#125; &#125; else &#123; // reset sequence to start with zero for the next millisecond sequence = 0; &#125; lastTimestamp = currentTimestamp; long id = currentTimestamp &lt;&lt; (NODE_ID_BITS + SEQUENCE_BITS) | (nodeId &lt;&lt; SEQUENCE_BITS) | sequence; return id; &#125; // Get current timestamp in milliseconds, adjust for the custom epoch. private long timestamp() &#123; return Instant.now().toEpochMilli() - customEpoch; &#125; // Block and wait till next millisecond private long waitNextMillis(long currentTimestamp) &#123; while (currentTimestamp == lastTimestamp) &#123; currentTimestamp = timestamp(); &#125; return currentTimestamp; &#125; private long createNodeId() &#123; long nodeId; try &#123; StringBuilder sb = new StringBuilder(); Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces(); while (networkInterfaces.hasMoreElements()) &#123; NetworkInterface networkInterface = networkInterfaces.nextElement(); byte[] mac = networkInterface.getHardwareAddress(); if (mac != null) &#123; for(byte macPort: mac) &#123; sb.append(String.format(&quot;%02X&quot;, macPort)); &#125; &#125; &#125; nodeId = sb.toString().hashCode(); &#125; catch (Exception ex) &#123; nodeId = (new SecureRandom().nextInt()); &#125; nodeId = nodeId &amp; maxNodeId; return nodeId; &#125; public long[] parse(long id) &#123; long maskNodeId = ((1L &lt;&lt; NODE_ID_BITS) - 1) &lt;&lt; SEQUENCE_BITS; long maskSequence = (1L &lt;&lt; SEQUENCE_BITS) - 1; long timestamp = (id &gt;&gt; (NODE_ID_BITS + SEQUENCE_BITS)) + customEpoch; long nodeId = (id &amp; maskNodeId) &gt;&gt; SEQUENCE_BITS; long sequence = id &amp; maskSequence; return new long[]&#123;timestamp, nodeId, sequence&#125;; &#125; @Override public String toString() &#123; return &quot;Snowflake Settings [EPOCH_BITS=&quot; + EPOCH_BITS + &quot;, NODE_ID_BITS=&quot; + NODE_ID_BITS + &quot;, SEQUENCE_BITS=&quot; + SEQUENCE_BITS + &quot;, CUSTOM_EPOCH=&quot; + customEpoch + &quot;, NodeId=&quot; + nodeId + &quot;]&quot;; &#125; &#125;&#125; Swagger 配置信息引入knife4j坐标 123456789&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi2-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; yml配置文件 1234567891011121314151617# springdoc-openapi项目配置springdoc: swagger-ui: tags-sorter: alpha operations-sorter: alpha api-docs: path: /v3/api-docs group-configs: - group: &#x27;default&#x27; paths-to-match: &#x27;/**&#x27; packages-to-scan: com.example.baidupan.controller # controller路径# knife4j的增强配置，不需要增强可以不配knife4j: enable: true setting: language: zh_cn 123456789101112131415161718192021222324252627282930313233343536373839404142// spring boot 2.x版本使用package com.example.baidupan.config;import org.springframework.context.annotation.Bean;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123; /** * 通过knife4j生成接口文档 * * @return */ @Bean public Docket docket() &#123; ApiInfo apiInfo = new ApiInfoBuilder() .title(&quot;仿百度网盘项目接口文档&quot;) .version(&quot;1.0&quot;) .description(&quot;仿百度网盘项目接口文档&quot;) .build(); return new Docket(DocumentationType.SWAGGER_2)// .groupName(&quot;管理端接口&quot;) .apiInfo(apiInfo) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.example.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); &#125;&#125; 验证码组件123456789101112131415161718public static final String CHECK_CODE_KEY = &quot;check_code_key&quot;;public static final String CHECK_CODE_KEY_EMAIL = &quot;check_code_key_email&quot;;public void checkCode(HttpServletResponse response, HttpSession session, Integer type) throws IOException &#123; CreateImageCode vCode = new CreateImageCode(130, 38, 5, 10); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); response.setContentType(&quot;image/jpeg&quot;); String code = vCode.getCode(); if (type == null || type == 0) &#123; session.setAttribute(Constants.CHECK_CODE_KEY, code); &#125; else &#123; session.setAttribute(Constants.CHECK_CODE_KEY_EMAIL, code); &#125; vCode.write(response.getOutputStream()); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194package com.example.baidupan.entity.dto;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.io.OutputStream;import java.util.Random;public class CreateImageCode &#123; // 图片的宽度。 private int width = 160; // 图片的高度。 private int height = 40; // 验证码字符个数 private int codeCount = 4; // 验证码干扰线数 private int lineCount = 20; // 验证码 private String code = null; // 验证码图片Buffer private BufferedImage buffImg = null; Random random = new Random(); public CreateImageCode() &#123; creatImage(); &#125; public CreateImageCode(int width, int height) &#123; this.width = width; this.height = height; creatImage(); &#125; public CreateImageCode(int width, int height, int codeCount) &#123; this.width = width; this.height = height; this.codeCount = codeCount; creatImage(); &#125; public CreateImageCode(int width, int height, int codeCount, int lineCount) &#123; this.width = width; this.height = height; this.codeCount = codeCount; this.lineCount = lineCount; creatImage(); &#125; // 生成图片 private void creatImage() &#123; int fontWidth = width / codeCount;// 字体的宽度 int fontHeight = height - 5;// 字体的高度 int codeY = height - 8; // 图像buffer buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = buffImg.getGraphics(); //Graphics2D g = buffImg.createGraphics(); // 设置背景色 g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); // 设置字体 //Font font1 = getFont(fontHeight); Font font = new Font(&quot;Fixedsys&quot;, Font.BOLD, fontHeight); g.setFont(font); // 设置干扰线 for (int i = 0; i &lt; lineCount; i++) &#123; int xs = random.nextInt(width); int ys = random.nextInt(height); int xe = xs + random.nextInt(width); int ye = ys + random.nextInt(height); g.setColor(getRandColor(1, 255)); g.drawLine(xs, ys, xe, ye); &#125; // 添加噪点 float yawpRate = 0.01f;// 噪声率 int area = (int) (yawpRate * width * height); for (int i = 0; i &lt; area; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); buffImg.setRGB(x, y, random.nextInt(255)); &#125; String str1 = randomStr(codeCount);// 得到随机字符 this.code = str1; for (int i = 0; i &lt; codeCount; i++) &#123; String strRand = str1.substring(i, i + 1); g.setColor(getRandColor(1, 255)); // g.drawString(a,x,y); // a为要画出来的东西，x和y表示要画的东西最左侧字符的基线位于此图形上下文坐标系的 (x, y) 位置处 g.drawString(strRand, i * fontWidth + 3, codeY); &#125; &#125; // 得到随机字符 private String randomStr(int n) &#123; String str1 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; String str2 = &quot;&quot;; int len = str1.length() - 1; double r; for (int i = 0; i &lt; n; i++) &#123; r = (Math.random()) * len; str2 = str2 + str1.charAt((int) r); &#125; return str2; &#125; // 得到随机颜色 private Color getRandColor(int fc, int bc) &#123;// 给定范围获得随机颜色 if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; /** * 产生随机字体 */ private Font getFont(int size) &#123; Random random = new Random(); Font font[] = new Font[5]; font[0] = new Font(&quot;Ravie&quot;, Font.PLAIN, size); font[1] = new Font(&quot;Antique Olive Compact&quot;, Font.PLAIN, size); font[2] = new Font(&quot;Fixedsys&quot;, Font.PLAIN, size); font[3] = new Font(&quot;Wide Latin&quot;, Font.PLAIN, size); font[4] = new Font(&quot;Gill Sans Ultra Bold&quot;, Font.PLAIN, size); return font[random.nextInt(5)]; &#125; // 扭曲方法 private void shear(Graphics g, int w1, int h1, Color color) &#123; shearX(g, w1, h1, color); shearY(g, w1, h1, color); &#125; private void shearX(Graphics g, int w1, int h1, Color color) &#123; int period = random.nextInt(2); boolean borderGap = true; int frames = 1; int phase = random.nextInt(2); for (int i = 0; i &lt; h1; i++) &#123; double d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames); g.copyArea(0, i, w1, 1, (int) d, 0); if (borderGap) &#123; g.setColor(color); g.drawLine((int) d, i, 0, i); g.drawLine((int) d + w1, i, w1, i); &#125; &#125; &#125; private void shearY(Graphics g, int w1, int h1, Color color) &#123; int period = random.nextInt(40) + 10; // 50; boolean borderGap = true; int frames = 20; int phase = 7; for (int i = 0; i &lt; w1; i++) &#123; double d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames); g.copyArea(i, 0, 1, h1, 0, (int) d); if (borderGap) &#123; g.setColor(color); g.drawLine(i, (int) d, i, 0); g.drawLine(i, (int) d + h1, i, h1); &#125; &#125; &#125; public void write(OutputStream sos) throws IOException &#123; ImageIO.write(buffImg, &quot;png&quot;, sos); sos.close(); &#125; public BufferedImage getBuffImg() &#123; return buffImg; &#125; public String getCode() &#123; return code.toLowerCase(); &#125;&#125; 通用业务异常信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.baidupan.exception;import com.example.baidupan.entity.enums.CodeEnum;public class BusinessException extends RuntimeException &#123; private CodeEnum codeEnum; private Integer code; private String message; public BusinessException(String message, Throwable e) &#123; super(message, e); this.message = message; &#125; public BusinessException(String message) &#123; super(message); this.message = message; &#125; public BusinessException(Throwable e) &#123; super(e); &#125; public BusinessException(CodeEnum codeEnum) &#123; super(codeEnum.getMsg()); this.codeEnum = codeEnum; this.code = codeEnum.getCode(); this.message = codeEnum.getMsg(); &#125; public BusinessException(Integer code, String message) &#123; super(message); this.code = code; this.message = message; &#125; public CodeEnum getCodeEnum() &#123; return codeEnum; &#125; public Integer getCode() &#123; return code; &#125; @Override public String getMessage() &#123; return message; &#125; /** * 重写fillInStackTrace 业务异常不需要堆栈信息，提高效率. */ @Override public Throwable fillInStackTrace() &#123; return this; &#125;&#125; MybatisX插件需要在静态资源的xml文件中先声明对应的类型 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.example.baidupan.mappers.UserInfoMapper&quot;&gt; &lt;/mapper&gt; mapper配置文件 1234567#mapper配置文件mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.example.baidupan.entity configuration: #开启驼峰命名 map-underscore-to-camel-case: true 邮件发送12345678910111213141516171819202122232425spring: #邮箱基本配置 mail: #配置smtp服务主机地址 host: smtp.qq.com #发送者邮箱 username: xxxxxxx@qq.com #配置密码,注意不是真正的密码，而是刚刚申请到的授权码 password: xxxxxxxxxxx #端口号465或587 port: 587 #默认的邮件编码为UTF-8 default-encoding: UTF-8 #其他参数 properties: mail: #配置SSL 加密工厂 smtp: ssl: #本地测试，先放开ssl enable: false required: false #开启debug模式，这样邮件发送过程的日志会在控制台打印出来，方便排查错误 debug: true MailRequest实体 1234567891011121314151617181920212223@Datapublic class MailRequest implements Serializable &#123; /** * 接收人 */ private String sendTo; /** * 邮件主题 */ private String subject; /** * 邮件内容 */ private String text; /** * 附件路径 */ private String filePath;&#125; SendMailService 1234567891011121314151617181920public interface SendMailService &#123; /** * 简单文本邮件 * * @param mailRequest * @return */ void sendSimpleMail(MailRequest mailRequest); /** * Html格式邮件,可带附件 * * @param mailRequest * @return */ void sendHtmlMail(MailRequest mailRequest);&#125; SendMailServiceImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Servicepublic class SendMailServiceImpl implements SendMailService &#123; //注入邮件工具类 @Autowired private JavaMailSender javaMailSender; @Value(&quot;$&#123;spring.mail.username&#125;&quot;) private String sendMailer; private static final Logger logger = LoggerFactory.getLogger(SendMailServiceImpl.class); public void checkMail(MailRequest mailRequest) &#123; Assert.notNull(mailRequest,&quot;邮件请求不能为空&quot;); Assert.notNull(mailRequest.getSendTo(), &quot;邮件收件人不能为空&quot;); Assert.notNull(mailRequest.getSubject(), &quot;邮件主题不能为空&quot;); Assert.notNull(mailRequest.getText(), &quot;邮件收件人不能为空&quot;); &#125; @Override public void sendSimpleMail(MailRequest mailRequest) &#123; SimpleMailMessage message = new SimpleMailMessage(); checkMail(mailRequest); //邮件发件人 message.setFrom(sendMailer); //邮件收件人 1或多个 message.setTo(mailRequest.getSendTo().split(&quot;,&quot;)); //邮件主题 message.setSubject(mailRequest.getSubject()); //邮件内容 message.setText(mailRequest.getText()); //邮件发送时间 message.setSentDate(new Date()); javaMailSender.send(message); logger.info(&quot;发送邮件成功:&#123;&#125;-&gt;&#123;&#125;&quot;,sendMailer,mailRequest.getSendTo()); &#125; @Override public void sendHtmlMail(MailRequest mailRequest) &#123; MimeMessage message = javaMailSender.createMimeMessage(); checkMail(mailRequest); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message,true); //邮件发件人 helper.setFrom(sendMailer); //邮件收件人 1或多个 helper.setTo(mailRequest.getSendTo().split(&quot;,&quot;)); //邮件主题 helper.setSubject(mailRequest.getSubject()); //邮件内容 helper.setText(mailRequest.getText(),true); //邮件发送时间 helper.setSentDate(new Date()); String filePath = mailRequest.getFilePath(); if (StringUtils.hasText(filePath)) &#123; FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName,file); &#125; javaMailSender.send(message); logger.info(&quot;发送邮件成功:&#123;&#125;-&gt;&#123;&#125;&quot;,sendMailer,mailRequest.getSendTo()); &#125; catch (MessagingException e) &#123; logger.error(&quot;发送邮件时发生异常！&quot;,e); &#125; &#125;&#125; Redis缓存工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.easypan.component;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import javax.annotation.Resource;import java.util.Collection;import java.util.concurrent.TimeUnit;@Component(&quot;redisUtils&quot;)public class RedisUtils&lt;V&gt; &#123; @Resource private RedisTemplate&lt;String, V&gt; redisTemplate; private static final Logger logger = LoggerFactory.getLogger(RedisUtils.class); /** * 删除缓存 * * @param key 可以传一个值 或多个 */ public void delete(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)); &#125; &#125; &#125; public V get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, V value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; logger.error(&quot;设置redisKey:&#123;&#125;,value:&#123;&#125;失败&quot;, key, value); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean setex(String key, V value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; logger.error(&quot;设置redisKey:&#123;&#125;,value:&#123;&#125;失败&quot;, key, value); return false; &#125; &#125;&#125; AOP切面全局校验规则注解 12345678910111213141516171819202122232425262728293031323334package com.example.baidupan.annotation;import org.springframework.web.bind.annotation.Mapping;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Mappingpublic @interface GlobalInterceptor &#123; /** * 校验登录，默认校验 * @return */ boolean checkLogin() default true; /** * 校验参数，默认不校验 * * @return */ boolean checkParams() default false; /** * 校验管理员，默认不校验 * @return */ boolean checkAdmin() default false;&#125; 参数校验注解 12345678910111213141516171819202122232425262728293031323334353637package com.example.baidupan.annotation;import com.example.baidupan.entity.enums.VerifyRegexEnum;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.PARAMETER, ElementType.FIELD&#125;)public @interface VerifyParam &#123; /** * 校验正则 * * @return */ VerifyRegexEnum regex() default VerifyRegexEnum.NO; /** * 最小长度 * * @return */ int min() default -1; /** * 最大长度 * * @return */ int max() default -1; boolean required() default false;&#125; 参数校验枚举 123456789101112131415161718192021222324252627282930package com.example.baidupan.entity.enums;public enum VerifyRegexEnum &#123; NO(&quot;&quot;, &quot;不校验&quot;), IP(&quot;([1-9]|[1-9]\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5])(\\\\.(\\\\d|[1-9]\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]))&#123;3&#125;&quot;, &quot;IP地址&quot;), POSITIVE_INTEGER(&quot;^[0-9]*[1-9][0-9]*$&quot;, &quot;正整数&quot;), NUMBER_LETTER_UNDER_LINE(&quot;^\\\\w+$&quot;, &quot;由数字、26个英文字母或者下划线组成的字符串&quot;), EMAIL(&quot;^[\\\\w-]+(\\\\.[\\\\w-]+)*@[\\\\w-]+(\\\\.[\\\\w-]+)+$&quot;, &quot;邮箱&quot;), PHONE(&quot;(1[0-9])\\\\d&#123;9&#125;$&quot;, &quot;手机号码&quot;), COMMON(&quot;^[a-zA-Z0-9_\\\\u4e00-\\\\u9fa5]+$&quot;, &quot;数字，字母，中文，下划线&quot;), PASSWORD(&quot;^(?=.*\\\\d)(?=.*[a-zA-Z])[\\\\da-zA-Z~!@#$%^&amp;*_]&#123;8,&#125;$&quot;, &quot;只能是数字，字母，特殊字符 8-18位&quot;), ACCOUNT(&quot;^[0-9a-zA-Z_]&#123;1,&#125;$&quot;, &quot;字母开头,由数字、英文字母或者下划线组成&quot;), MONEY(&quot;^[0-9]+(.[0-9]&#123;1,2&#125;)?$&quot;, &quot;金额&quot;); private String regex; private String desc; VerifyRegexEnum(String regex, String desc) &#123; this.regex = regex; this.desc = desc; &#125; public String getRegex() &#123; return regex; &#125; public String getDesc() &#123; return desc; &#125;&#125; 全局操作拦截切面 LoginVO是登录成功返回的data封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213package com.example.baidupan.aspect;import com.example.baidupan.annotation.GlobalInterceptor;import com.example.baidupan.annotation.VerifyParam;import com.example.baidupan.entity.constant.Constants;import com.example.baidupan.entity.dox.UserInfo;import com.example.baidupan.entity.enums.CodeEnum;import com.example.baidupan.entity.vo.LoginVO;import com.example.baidupan.exception.BusinessException;import com.example.baidupan.service.UserInfoService;import com.example.baidupan.utils.StringTools;import com.example.baidupan.utils.VerifyUtils;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpSession;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.ArrayUtils;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.util.List;/** * AOP 切面类：处理登录、权限、参数校验 */@Slf4j@Aspect@Componentpublic class GlobalOperationAspect &#123; @Value(&quot;$&#123;dev&#125;&quot;) private Boolean dev; @Autowired private UserInfoService userInfoService; private static final String[] TYPE_BASIC = &#123;&quot;java.lang.String&quot;, &quot;java.lang.Integer&quot;, &quot;java.lang.Long&quot;&#125;; @Pointcut(&quot;@annotation(com.example.baidupan.annotation.GlobalInterceptor)&quot;) public void requestInterception() &#123; &#125; @Before(&quot;requestInterception()&quot;) public void interceptorDo(JoinPoint point) throws BusinessException &#123; try &#123; /// 获取被拦截类实例 Object target = point.getTarget(); /// 获取目标方法参数 Object[] arguments = point.getArgs(); /// 获取目标方法名 String methodName = point.getSignature().getName(); /// 获取方法对象 Class&lt;?&gt;[] parameterTypes = ((MethodSignature) point.getSignature()).getMethod().getParameterTypes(); Method method = target.getClass().getMethod(methodName, parameterTypes); /// 通过方法实例检查目标方法上是否存在该注释 GlobalInterceptor interceptor = method.getAnnotation(GlobalInterceptor.class); if (interceptor == null) &#123; return; &#125; /** * 校验登录 */ if (interceptor.checkLogin() || interceptor.checkAdmin()) &#123; checkLogin(interceptor.checkAdmin()); &#125; /** * 校验参数 */ if (interceptor.checkParams()) &#123; validateParams(method, arguments); &#125; &#125; catch (BusinessException e) &#123; log.error(&quot;全局拦截器异常&quot;, e); throw e; &#125; catch (Exception e) &#123; log.error(&quot;全局拦截器异常&quot;, e); throw new BusinessException(CodeEnum.CODE_500); &#125; catch (Throwable e) &#123; log.error(&quot;全局拦截器异常&quot;, e); throw new BusinessException(CodeEnum.CODE_500); &#125; &#125; //校验登录 private void checkLogin(Boolean checkAdmin) &#123; HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); HttpSession session = request.getSession(); LoginVO loginVO = (LoginVO) session.getAttribute(Constants.SESSION_KEY); /// 开发环境处理，如果是开发环境且用户未登录，自动获取第一个用户登录// if (loginVO == null &amp;&amp; dev != null &amp;&amp; dev) &#123;// List&lt;UserInfo&gt; userInfoList = userInfoService.findListByParam(new UserInfoQuery());// if (!userInfoList.isEmpty()) &#123;// UserInfo userInfo = userInfoList.get(0);// loginVO = LoginVO.builder()// .userId(userInfo.getUserId())// .nickName(userInfo.getNickName())// .admin(true)// .build();// session.setAttribute(Constants.SESSION_KEY, loginVO);// &#125;// &#125; if (loginVO == null) &#123; throw new BusinessException(CodeEnum.CODE_901); &#125; if (checkAdmin &amp;&amp; !loginVO.getAdmin()) &#123; throw new BusinessException(CodeEnum.CODE_404); &#125; &#125; /** * 通过m.getParameters()获取的参数只包含参数类型,参数名等信息 * arguments数组仅仅是具体的参数值，其与m.getParameters()的参数数组一一对应 * * @param m * @param arguments * @throws BusinessException */ private void validateParams(Method m, Object[] arguments) throws BusinessException &#123; /// 获取参数数组 Parameter[] parameters = m.getParameters(); for (int i = 0; i &lt; parameters.length; i++) &#123; Parameter parameter = parameters[i]; Object value = arguments[i]; VerifyParam verifyParam = parameter.getAnnotation(VerifyParam.class); if (verifyParam == null) &#123; continue; &#125; //基本数据类型 if (ArrayUtils.contains(TYPE_BASIC, parameter.getParameterizedType().getTypeName())) &#123; checkValue(value, verifyParam); //如果传递的是对象 &#125; else &#123; checkObjValue(parameter, value); &#125; &#125; &#125; /** * 针对对象的，需要遍历内部确定是否存在@VerifyParam注解 * * @param parameter * @param value */ private void checkObjValue(Parameter parameter, Object value) &#123; try &#123; /// 获取参数类型名 String typeName = parameter.getParameterizedType().getTypeName(); Class classz = Class.forName(typeName); Field[] fields = classz.getDeclaredFields(); for (Field field : fields) &#123; VerifyParam fieldVerifyParam = field.getAnnotation(VerifyParam.class); if (fieldVerifyParam == null) &#123; continue; &#125; field.setAccessible(true); // 允许访问私有字段 Object resultValue = field.get(value); // 获取字段值 checkValue(resultValue, fieldVerifyParam); // 校验字段值 &#125; &#125; catch (BusinessException e) &#123; log.error(&quot;校验参数失败&quot;, e); throw e; &#125; catch (Exception e) &#123; log.error(&quot;校验参数失败&quot;, e); throw new BusinessException(CodeEnum.CODE_600); &#125; &#125; /** * 参数校验 * * @param value * @param verifyParam * @throws BusinessException */ private void checkValue(Object value, VerifyParam verifyParam) throws BusinessException &#123; Boolean isEmpty = value == null || StringTools.isEmpty(value.toString()); Integer length = value == null ? 0 : value.toString().length(); /** * 校验空 */ if (isEmpty &amp;&amp; verifyParam.required()) &#123; throw new BusinessException(CodeEnum.CODE_600); &#125; /** * 校验长度 */ if (!isEmpty &amp;&amp; (verifyParam.max() != -1 &amp;&amp; verifyParam.max() &lt; length || verifyParam.min() != -1 &amp;&amp; verifyParam.min() &gt; length)) &#123; throw new BusinessException(CodeEnum.CODE_600); &#125; /** * 校验正则 */ if (!isEmpty &amp;&amp; !StringTools.isEmpty(verifyParam.regex().getRegex()) &amp;&amp; !VerifyUtils.verify(verifyParam.regex(), String.valueOf(value))) &#123; throw new BusinessException(CodeEnum.CODE_600); &#125; &#125;&#125; 基本工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package com.example.baidupan.utils;import com.example.baidupan.entity.constant.Constants;import jakarta.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;import org.apache.commons.codec.digest.DigestUtils;import org.apache.commons.lang3.RandomStringUtils;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;@Slf4jpublic class StringTools &#123; public static final String getRandomString(Integer count) &#123; return RandomStringUtils.random(count, true, true); &#125; /// 获得验证码 public static final String getRandomNumber(Integer count) &#123; return RandomStringUtils.random(count, false, true); &#125; /// 判断是否为空 public static boolean isEmpty(String str) &#123; if (null == str || &quot;&quot;.equals(str) || &quot;null&quot;.equals(str) || &quot;\\u0000&quot;.equals(str)) &#123; return true; &#125; else if (&quot;&quot;.equals(str.trim())) &#123; return true; &#125; return false; &#125; /// 加密ByMD5 public static String encodeByMD5(String originString) &#123; return StringTools.isEmpty(originString) ? null : DigestUtils.md5Hex(originString); &#125; /// 获取文件名的后缀 public static String getFileSuffix(String fileName) &#123; Integer index = fileName.lastIndexOf(&quot;.&quot;); if (index == -1) &#123; return &quot;&quot;; &#125; String suffix = fileName.substring(index); return suffix; &#125; /// 获取不带后缀的文件名 public static String getFileNameNoSuffix(String fileName) &#123; Integer index = fileName.lastIndexOf(&quot;.&quot;); if (index == -1) &#123; return fileName; &#125; fileName = fileName.substring(0, index); return fileName; &#125; /// 文件重命名 public static String rename(String fileName) &#123; String fileNameReal = getFileNameNoSuffix(fileName); String suffix = getFileSuffix(fileName); return fileNameReal + &quot;_&quot; + getRandomString(Constants.LENGTH_5) + suffix; &#125; /// 基础HTML转义 public static String escapeTitle(String content) &#123; if (isEmpty(content)) &#123; return content; &#125; content = content.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;); return content; &#125; /// 完整的HTML转义 public static String escapeHtml(String content) &#123; if (isEmpty(content)) &#123; return content; &#125; content = content.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;); content = content.replace(&quot; &quot;, &quot;&amp;nbsp;&quot;); content = content.replace(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;); return content; &#125; /// 路径安全检查 public static boolean pathIsOk(String path) &#123; if (StringTools.isEmpty(path)) &#123; return true; &#125; if (path.contains(&quot;../&quot;) || path.contains(&quot;..\\\\&quot;)) &#123; return false; &#125; return true; &#125; /// 读取文件流 public static void readFile(HttpServletResponse response, String filePath) &#123; if (!StringTools.pathIsOk(filePath)) &#123; return; &#125; OutputStream out = null; FileInputStream in = null; try &#123; File file = new File(filePath); if (!file.exists()) &#123; return; &#125; in = new FileInputStream(file); byte[] byteData = new byte[1024]; out = response.getOutputStream(); int len = 0; while ((len = in.read(byteData)) != -1) &#123; out.write(byteData, 0, len); &#125; out.flush(); &#125; catch (Exception e) &#123; log.error(&quot;读取文件异常&quot;, e); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; log.error(&quot;IO异常&quot;, e); &#125; &#125; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; log.error(&quot;IO异常&quot;, e); &#125; &#125; &#125; &#125;&#125; redis组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.example.baidupan.utils;import jakarta.annotation.Resource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.Collection;import java.util.concurrent.TimeUnit;@Component(&quot;redisUtils&quot;)public class RedisUtils&lt;V&gt; &#123; @Resource private RedisTemplate&lt;String, V&gt; redisTemplate; private static final Logger logger = LoggerFactory.getLogger(RedisUtils.class); /** * 删除缓存 * * @param key 可以传一个值 或多个 */ public void delete(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)); &#125; &#125; &#125; public V get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, V value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; logger.error(&quot;设置redisKey:&#123;&#125;,value:&#123;&#125;失败&quot;, key, value); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean setex(String key, V value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; logger.error(&quot;设置redisKey:&#123;&#125;,value:&#123;&#125;失败&quot;, key, value); return false; &#125; &#125;&#125; redis配置，防止序列化乱码 123456789101112131415161718192021222324252627package com.example.baidupan.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;@Configuration(&quot;redisConfig&quot;)public class RedisConfig&lt;V&gt; &#123; @Bean public RedisTemplate&lt;String, V&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, V&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(factory); // 设置key的序列化方式 template.setKeySerializer(RedisSerializer.string()); // 设置value的序列化方式 template.setValueSerializer(RedisSerializer.json()); // 设置hash的key的序列化方式 template.setHashKeySerializer(RedisSerializer.string()); // 设置hash的value的序列化方式 template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; &#125;&#125;","path":"2025/03/09/常用组件/","date":"03-09","excerpt":"","tags":[{"name":"后端常用","slug":"后端常用","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8/"}]},{"title":"","text":"设置 Redis 服务开机自启首先注册redis服务： 在redis的根目录下打开cmd，输入如下命令 1redis-server.exe --service-install redis.windows.conf --loglevel verbose 成功注册后，打开运行窗口（win + R） 输入services.msc 打开服务窗口，找到redis设置启动类型为自动即可 关闭Redis服务开机自启只需要在redis的根目录下打开cmd，输入如下命令卸载redis服务即可 1redis-server --service-uninstall","path":"2025/02/25/redis启动/","date":"02-25","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"软件体系结构","text":"软件体系结构概论工学：即工程学科的总称，工程学是一门应用学科，是用数学和其他自然学科的原理来设计有用物体的进程，研究自然科学应用在各行业中的应用方式，方法的一门学科，同时也研究工程进行的一般规律，并进行改良研究 工程：狭义：以某种设想的目标为依据，应用有关的科学知识和技术手段，通过一群人的有组织活动将某个或某些现有实体（自然或人造）转化为具有使用价值的人造产品的过程。广义：由一群人为达到某种目的，在一个较长时间周期内进行协作活动的过程 软件工程：是一门研究用工程化方法，构建和维护有效的，实用的和高质量的软件的学科 软件危机主要表现：成本日益增长，开发进度难以控制，软件质量差，维护困难 产生原因：用户需求不明确，缺乏正确的理论指导，软件规模越来越大，软件发杂度越来越高 工程的内涵：研究，设计，开发，生产，施工，操作，管理 科学 工程 目的 发现认知 发明运用 方法 分析归纳 创造演绎 成本 不计代价 精打细算 贡献 知识开阔 生活改善 软件重用软件重用：在两次或多次不同的软件开发过程中，重复使用相同或相近软件元素的过程 可重用的元素：程序代码，设计文档，需求分析文档，测试用例，设计过程，领域知识 关键技术：面向对象思想，组件化开发技术，软件架构设计，领域工程 构件：语意完整，语法正确，有可重用价值的单位软件，是软件重用过程中可以明确辨识的系统，结构上它是语义描述，通信接口和实现代码的复合体 构建的规模？ 构件实现：具体实现构件功能的逻辑系统，即代码构件 围绕构件展开的工作：构件获取——构件管理——构件重用 重用技术与领域之间的关系：领域具有内聚性，稳定性——前提 可重用信息具有领域特定性——约束 构件获取的获取途径：修改，提取，购买 构件描述：管理角度的细节刻画 构件模型：本质的抽象描述 构件组织要求：支持构件库维护，查找，精确描述领域，易于使用 方法：关键字法，刻面法，超文本法 构件检索 优点 缺点 基于关键字法 简单易行 用户不一定能恰当运用关键字进行描述 基于刻面法 便于实现相似构件的查找 构造查询困难 基于超文本法 人性化操作 迷失，效率低 软件体系结构建模建模：建立系统模型的过程 “4+1”视图模型最终用户：功能需求（逻辑视图） 主要是整个系统的抽象结构表述，关注系统提供最终用户的功能 逻辑视图设计中要注意的主要问题是要保持一个单一的，内聚的对象模型贯穿整个系统 编程人员：软件管理（开发视图） 主要侧重软件模块的组织和管理，为编程人员服务。主要考虑软件内部需求，要充分考虑软件开发的容易程度，重用性，软件的通用性，充分考虑由于具体开发工具不同而带来的局限性 系统集成人员：性能可扩充性，吞吐量等（进程视图） 侧重系统的运行特性，关注非功能需求。定义逻辑视图中的各个类的操作是在哪一个线程中被执行 系统工程人员：系统拓扑，安装，通信等（物理视图） 如何把软件映射到硬件上，关注系统性能，规模，可靠性等 场景：重要系统活动的抽象，最重要的需求抽象，联系4个视图 软件体系结构的抽象模型构件定义：构件是一个数据单元或一个计算单元，它由构件的对象的集合，属性的集合，动作的集合和端口的集合组成 抽象表示为 C&#x3D;（O，A，X，P），O是构件的所有对象的集合，A是构件属性的集合，X是构件动作的集合，P是构件端口的集合 设C_1和C_2是软件系统S的两个不同构件，如果它们满足下列条件：C_1.O&#x3D;C_2.O，C_1.A&#x3D;C_2.A，C_1.X&#x3D;C_2.X，C_1.P&#x3D;C_2.P，则称C_1和C_2相等，记作C_1&#x3D;C_2 连接件的抽象定义：设论域为U，构件是一个软件体系结构，连接件是一个软件体系结构，构件经有限次连接（运算）后是软件体系结构，软件体系结构记为A&#x3D;&lt; C，O &gt;，其中C表示组成体系结构的构件的集合，0表示构件运算的集合 性质：封闭性（即构件与构件、构件与体系结构、体系结构与体系结构连接后仍是一个体系结构），层次性（即构件与构件、构件与体系结构、体系结构与体系结构连接后仍是一个体系结构），可扩充性（即一个满足条件的新构件可以通过连接加入到结构中） 软件体系结构风格软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式，反映了众多系统所共有的结构和语义特性，指导如何将各个模块和子系统有效地组织成一个完整的系统 控制原则（根本）和质量属性（表现）区分了风格 管道过滤器风格优点：构件间耦合关系降低，易于分解问题，实现重用，易于维护和扩展，为系统的运行分析提供便携条件，支持并发计算 缺点：在复杂应用问题中适用受限，数据解析、合成代价高，全局性能优化困难 扩展形式：管线，有界管道，批处理 数据抽象和面向对象组织优点：封装性、继承和多态，便于重用，可实现交互，易于理解和建模 缺点：调用使得修改被传播，设计复杂性增加，对象开销和消息传递导致的性能问题 事件驱动风格优点：实时处理和响应能力强，松耦合，为系统改进提供方便 缺点：系统逻辑关系复杂，弱化了对系统计算的控制能力，调试困难，有数据共享的负担 分层系统工作机制：每个层次为上一层提供服务，它同时作为用户调用下层的功能，严格的分层，半透明的分层 优点：支持基于抽象程度递增的系统设计，良好的扩展性，支持重用 缺点：层次划分困难，适用性受限 仓库系统及知识库（数据共享）要素：两类构件：中央数据单元，外部构件；控制策略：两类构件间的交互方式 分类：传统数据库型（被动），黑板系统（主动） C2特点：基底独立性，构件只见交互只能通过消息传递实现，多线程","path":"2024/12/08/软件体系结构/","date":"12-08","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"计算机组成原理","text":"输入输出系统组成：I&#x2F;O软件，I&#x2F;O硬件 三种方式：程序查询方式，程序中断方式，DMA方式 计算机的运算方法+0和-0的补码相同都是0，0000 浮点数表示 规格化之后： IEEE 754标准 单精度浮点数字长32位，尾数长度23，指数长度8，指数偏移量127 双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023 约定小数点左边隐含有一位，通常这位数是1，所以单精度尾数长度实际为24（默认省略小数点左边的1则为23），双精度尾数长度实际为54（默认省略小数点左边的1则为53） 定点运算算术移位规则（有符号位时，符号位不变）： 正数的原码，补码，反码均用0填充，负数中原码用0填充，补码时左移填0，右移填1，反码用1填充 浮点四则运算需要两位符号位 先看是否右规，再看是否左规（只做一种） 右规，但符号位出现10或01时采用，阶码加1；左规，符号位和第一个数位相同开始左规直至不同，阶码减1 指令系统寻址方式 指令寻址 数据寻址——约定：指令字长&#x3D;存储字长&#x3D;机器字长{1.立即寻址，2.直接寻址，3.隐含寻址，4.间接寻址，5.寄存器寻址，6.寄存器间接寻址，7.基址寻址，8.变址寻址，9.相对寻址，10.堆栈寻址} CPU的结构和功能指令周期：取出并执行一条指令所需的全部时间（取指，分析（取值周期），执行（执行周期）） 吞吐率：单位时间内流水线所完成指令或输出结果的数量 控制单元的分析与设计指令周期：取出并执行一条指令所需的全部时间 机器周期：控制器设定的标准机器操作周期值 时钟周期：完成一个基本的数据传递操作所需的时间值","path":"2024/12/04/计算机组成原理/","date":"12-04","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"系统分析与设计","text":"绪论系统是一组为实现某些结果按一定方式进行相互联系，相互作用的部件的集合体 系统的特性：整体性（系统是一个整体，不是各个要素的简单相加，它的整体功能是各要素在孤立状态下所没有的——系统最基本的特性），目的性（任何系统都具有某种目的，都要实现一定的功能，这也正是区别不同系统的标志），相关性（系统内各部分之间存在着相互依赖和相互制约的特定关系，某部分的变化会影响其他部分的实现功能），环境适应性（系统具有适应环境化，保持原有功能的特性），层次性（子系统，各层有独立功能） 系统分析：对一种业务问题域的学习活动，能够在系统解决方案中为提升系统性能和明确业务需求提供良好的建议（理解问题域） 系统设计：是对系统分析中已确定的业务希求的说明或者构建一种相关技术的解决方案（求可行解） 五大模型：瀑布模型，快速原型模型，增量模型，螺旋模型，喷泉模型 DecOps：是实践方法，高质量下缩短系统变更从提交到部署至生产环境的时间 系统规划系统规划是指定系统的长期发展方案，决定系统在整个生命周期内的发展方向，规模和发展进程。是生命周期的第一阶段 特点：周期长，投资大，不确定性，结构化低，全局性，面向高层是管理决策过程，不宜过细，着眼子系统划分，与企业规划同步，不针对部门 步骤：对当前系统进行初步调查，分析和确定新系统目标，分析子系统组成和功能，拟定系统实施方案，进行可行性研究 系统规划模型：诺兰模型（初装，蔓延，控制，集成，数据管理，成熟） CMM模型用来评估组织的信息系统开发以及管理过程和产品成熟度等级的框架，由五个开发等级，用一组被称为关键过程领域的指导方针进行度量 1级（初始级）——建立项目纪律——2级（管理级）——稳定一致的过程——3级（定义级）——以事实为依据——4级（定量级）——能够持续改进——5级（优化级） 战略集转换法——SST：把整个战略目标看成是一个“信息集合”，由使命，目标，战略和其他战略变量等组成，MIS的战略规划过程是把组织的战略目标转化为管理信息系统战略目标的方法 关键成功因素法——CSF：通过分析找出使得企业成功的关键因素，然后再围绕这些关键因素来确定系统的需求，并进行规划 企业系统规划法——BSP：为指导企业管理信息系统的开发而建立的规范方法。用于企业内部系统开发。自上而下识别系统目标，识别企业的过程，识别数据，然后再自下而上地设计系统目标，最后把企业目标转为信息系统规划地全过程 UC： 完备性检验，每个数据类必须有一个生产者C和至少一个使用者U，每个功能必须有产生或使用（U或C）数据类型 ​ 一致性检验：每个数据类必须有且仅有一个产生者C ​ 无冗余性检验：指U&#x2F;C矩阵中不允许有空行或空列 系统分析需求：个体客观或主观上的一种诉求。一般源自于用户理想上与现实的差距所致 刚需：某一类人的必要要求 需求的分类——层次角度：业务需求（最高层次目标，描述了组织为什么要开发系统），用户需求（描述了系统能够帮助用户做些什么），系统需求（可以直接映射为系统行为，定义了系统中需要实现的功能，描述了开发人员需要实现什么） 需求的分类——功能性角度：功能需求（表现为系统和环境之间的行为交互），性能需求，质量属性，约束条件，接口 系统分析：系统分析将一个系统分解成各个组成成分，目的是研究各部分如何工作，如何交互，以实现系统的目标。是问题解决技术 需求获取来源：涉众，硬数据，重要文档，相关技术标准和法规，相关产品 硬数据：定量硬数据（数据收集表格，统计报表），定性硬数据 需求获取的方法：面谈法（面谈结构：金字塔，漏斗，菱形），问卷，原型法，观察法，文档审查 需求分析流程：业务分析，需求建模（DFD，ERD，活动图等），需求细化，确定优先级，需求协商 业务流程图 系统流程图 数据流图 面向对象三大特征：封装性，继承性，多态性 三大类十种图： 用例模型图（功能模型）：有用例图组成 静态模型图（对象模型）：类图，包图，对象图，构件图，配置图 动态模型图（行为模型包括交互，状态模型）：活动图，状态图，顺序图，合作图 用例图（小人那个）优秀的需求文档：完备性，一致性，根据重要性和稳定性分级，可修改，可跟踪 需求验证方法：评审，原型与模型，开发测试用例，用户手册编制，利用跟踪关系，自动化分析 需求基线：已通过正式评审和批准的规格说明或产品，可作为进一步开发的基础，且只有通过正式的变更控制过程才能修改它 面向对象设计类的分类——边界类（用户界面类，系统和设备接口类），控制类，实体类、 这个是边界类，控制类则是在圆上有个箭头，实体类是圆下面有个线（像旦） 类之间的关联：建立实例连接，消息传递，筛选对象间的关联 消息：从一个对象向另一个或几个其他对象发送信号，或由一个对象调用另一个对象的操作。是对象之间在一次交互中所传送的消息 组成：发送者，接收者，活动 顺序图用来描述对象间的交互行为 写作图 活动图 状态图描述系统中某些对象所具有的各种状态，和该对象从一种状态到另一种状态的转移，以及影响对象这些状态的事件 构建图物理方面建模时要用的两种图之一，说明构件之间的逻辑实现 部署图&#x2F;配置图 原则七种不良设计：僵硬，脆弱，低复用，高粘度，无端复杂性，无端复制，晦涩 七种设计模式原则： 单一职责原则SRP——一个设计元素只做一件事 开放-封闭原则OPC——系统中的可变性因素都封装起来 里氏代换（Liskov）原则LSP——一个派生类完全代替一个基类 依赖倒置原则DIP——改掉过程化的高层依赖低层，变成细节依赖抽象 接口隔离原则ISP——尽量提供小接口 优先使用组合而不是继承原则（合成复用原则）CRP——希望低耦合 迪米特原则LoD——最少知识原则","path":"2024/12/01/系统分析与设计/","date":"12-01","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Web前端","text":"JSON在json中仅允许使用双引号来包裹字符串，也就是说字符串中出现双引号会出错，此时需要转义 123&#123; &quot;prome&quot; : &quot;Say \\&quot;Hello\\&quot; to you.&quot;&#125; json中布尔类型只能使用小写形式“true”和“false” HTML5网页标题标签，若省略则显示“无标题文档” 基础地址标签，为页面所有链接设置默认url，其中target&#x3D;“_blank”会使文档中所有未指定打开方式的超链接在新窗口打开 元数据标签，charset声明编码格式，搜索引擎会根据name（keywords，description）和content属性索引网页 样式标签， 链接标签，表示用于连接外部资源，只出现在head中 脚本标签 水平线标签 换行标签 斜体字标签和 粗体字标签和 上标标签和下标标签 修订标签和 预格式化标签 有序列表，默认使用阿拉伯数字，可以用type声明类型值，a：英文小写，A：英文大写，i：罗马数字小写，I：罗马数字大写，1：阿拉伯数字 无序列表 定义列表 图像标签，alt：无法找到图像时的代替文本内容 超链接标签，herf：目的url，target：打开方式 表格标签，行，单元格，表头，标题 框架标签 容器标签块级元素，还有，，- 容器标签内联元素 节标签 文章标签 侧栏标签 记号标签 进度标签，valus，max属性 注释 字符实体，用&（字符名称）或&#（实体数字） 表单部分：form标签，action：url地址，method：提交方式，name：表单名称，enctype：表单数据传递的编码方式 imput标签，type：输入类型【单选框radio设置相同的name值即可组合在一起使用（checked可以设置为默认选中），复选框checkbox同样设置相同name（checked同样可以设置默认选中），submit提交，reset重置，image图片提交按钮（src和alt），file文件上传域，hidden隐藏域】，name：自定义名称，（value：默认初始值） label标签，使用for属性应用对应表单控件的id，也可以直接包含input 多行文本标签textarea，cols：每行中的字符数，rows：显示的行数 select列表标签，内容用opton标签（使用selected默认选中），optgroup定义选项组 button按钮标签 fieldset域标签（用form表单包裹），legend域标题标签（用fieldset包裹） CSS内联样式表，通过style属性，（标签属性） 内部样式表，使用style标签 外部样式表，在head中使用link标签 内联>内部>外部 选择器：元素选择器，标签（元素名称）{} id选择器，#id{} 类选择器，.class{} 属性选择器，元素名称[元素属性]{}，a[href~=\"www\"] 所有链接中带有www的选择，a[href|=\"www\"] 所有链接中以www开头的 通配符选择器，*{}选择所有标签 交集选择器，标签+#id（或.class）不能有空格 并集选择器，有空格 后代选择器 语法注释 /**/，charset在外部样式表中设定字符编码，!improtant标记css样式的优先级 dispaly：inline行内元素，共享一行，内边距有效，外边距左右有效 block块级元素，独占一行，内外边距均有效 inline-block不独占一行的块级元素 JSconcat方法可以进行字符串拼接，也可以用”+“ indexOf可以查找字符串 将函数写在（）中代表匿名函数，没有名字，直接调用一次 箭头函数：var 函数名 =（变量） => ｛函数体｝ document.getElementById/getElementsByTagName/getElementsByClassName 改变html元素内容，变量名.innerHTML jQuery基础语法：$().(具体操作) 层次选择器： 子元素选择器，$(\"父>子\").操作 后代选择器，$(\"整体 整体中的某个个体\").操作 后相邻选择器，$(\"与谁相邻+要求相邻的标签\") 后兄弟选择器，$(\"与谁相邻~要求相邻的兄弟的标签\") 1234$(document).ready(funtion()&#123; $(&quot;&quot;).(funtion()&#123; &#125;);&#125;); 表单事件，blur表单失去焦点触发，focus获得焦点，change输入框或者下拉菜单内容变化，select有文字被选中，submit提交表单触发 事件绑定：.on(\"事件（必须有）\",\"子事件\",\"额外传递数据\",\"事件触发执行函数\") 事件接触.off()(\"事件（必须有）\",\"子事件\",\"额外传递数据\",\"事件触发执行函数\") 临时事件.one(\"事件（必须有）\",\"子事件\",\"额外传递数据\",\"事件触发执行函数\") VUEvue是基于MVVM（——数据模型，视图，视图模型）的框架 vue四个特性：数据驱动视图，双向数据绑定，插件，指令 每个单文件组件有模板（template），样式（style），逻辑组成（script） ref函数用于将数据变为响应式数据 reactive函数定义响应式数据 toRef将响应式对象中的单个属性转换为响应数据 toRefs将响应式对象中的所有属性值转为响应式数据 v-on：事件名可以简写为@事件名 v-model：双向数据绑定 $event获取事件对象 组件冲突：scoped属性，:deep（）深度选择器 父组件向子组件传递数据，先在子组件中声明props 子组件向父组件传递数据，在子组件中声明emits，在setup中调用defineEmits 跨组件之间进行数据传递：provide（注入名，注入值），inject（注入值，默认值，布尔值） KeepAlive组件可以实现组件缓存： 123&lt;KeepAlive&gt; &lt;component :is=&quot;showComponent&quot;&gt;&lt;/component&gt;&lt;/KeepAlive&gt; 组件激活onActivated生命周期函数，onDeactivated缓存生命周期 插槽：slot，具名插槽v-slot: === #，作用域插槽","path":"2024/11/26/Web前端/","date":"11-26","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"计算机网络","text":"计算机网络概述1983 年作为因特网的诞生时间 因特网分为边缘部分和核心部分 往返时间RTT，$$ 有效数据效率&#x3D;{数据长度 \\over 发送时间+RTT} $$ 物理层，数据链路层，网络层，运输层，（会话层），（表示层），应用层 物理层特性：机械特性，电气特性，功能特性，过程特性 用途：创建电信号，光信号，微波信号 规定了信号，连接器和电缆要求 奈奎斯特公式：$$ C&#x3D;Blog2^N ,B&#x3D;2H$$,B是最高码元速率（信号传输速率）$$ S&#x3D;B*log2^N，S&#x3D;{1\\over T}*log2^N $$, 香农公式：$$ C&#x3D;H*log2(1+{S \\over N}) ，其中S&#x2F;N位信噪比，信噪比表示为：10lg({S \\over N})$$ 数据链路层数据链路层三个问题：封装成帧，透明传输，差错控制 高速以太网：100Base-T，MAC帧位802.3，帧间间隔位0.96微秒 网络层无连接：虚电路，连接：数据报 用转发器或者网桥连接起来的局域网仍为一个网络，具有相同的网络号 子网掩码的1的个数即为网络位位数，32-（1的个数）即为主机位的位数 求网络地址： 用ip地址和子网掩码进行与运算，得到的即为网络地址 ip地址数&#x3D;$$ 2^{主机位的位数} $$，划分子网网段数&#x3D;$$ 2^{子网位的位数} $$ ipv6的目的地址：单薄，多播，任播 ipv4的首部有20个字节是固定的，所有的ipv4数据报都具有 ipv6的六种扩展首部：逐跳选项，路由选择，分片，鉴别，封装安全有效载荷，目的站选择 arp协议作用：从网络层使用的ip地址，解析出在数据链路层使用的物理地址 邻居发现协议：路由器宣告，路由器请求，路由器重定向，邻居请求和邻居宣告 rip协议：好消息传播的快，坏消息传播的慢 交换结构把分组从一个输入端口转移到某个合适的输出端口，有三种常用的方法：通过存储器，通过总线，通过纵横交换结构 IP多播目的：更好地支持一对多通信————多播地址只能用于目的地址不能用于源地址 tcp&#x2F;ip协议使用的mac地址范围：从00-00-5E-00-00-00到00-00-5E-7F-FF-FF ip多播两种协议：IGMP和多播路由选择协议 多播路由选择协议在转发多播数据报时使用的三种方法：洪泛与剪除，隧道技术，基于核心的发现技术 运输层面向连接的TCP，无连接UDP 运输层属于面向通信部分的最高层，同时也是用户功能中的最底层 运输层的重要功能：复用和分用 tcp传送的数据单位协议：tcp报文，udp是udp报文和用户数据报（相对于udp，tco不支持多播和广播，只支持点对点的单薄） tcp提供全双工通信，面向字节流，tcp不保证接收方和发送发所发出的数据块具有对应大小关系，但字节流完全一样 tcp连接的端点——套接字（端口号拼接到ip地址），tcp使用流水线和滑动窗口协议实现高效，可靠传输，tcp的滑动窗口是以字节为单位的 连接运输的三个阶段：连接建立，数据传送，连接释放 tcp连接的建立采用客户服务器方式，客户(client)，服务器（server） 出现拥塞的原因：$$ \\sum 对资源需求 $$ &gt; 可用资源 分组丢失是网络发生拥塞的征兆不是原因 $$ 真正的发送窗口值&#x3D; MIN(接收方窗口值，拥塞窗口值)$$，重传定时器超时：网络已经发生拥塞，收到三个重复的ack：预示网络可能会出现拥塞 tcp拥塞控制算法：慢开始（由小到大逐渐增大拥塞窗口值），拥塞避免，快重传（发送发一连收到三个重复确认），快恢复 发送窗口的上限值&#x3D;min（接收方窗口rwnd，拥塞窗口cwnd） “三次握手”的目的是为了解决“网络中存在延迟的重复分组” 应用层主机向本地域名服务器的查询一般采用递归查询，本地域名服务器向根域名服务器的查询通常采用迭代查询 域名与ip地址的关系：一对多，一对多 ftp使用tcp，tftp使用udp http使用了tcp，http是面向事务的，http协议是无状态的 无线网络和移动网络低速WPAN标准：IEEE 802.15.4 高速WPAN标准：IEEE 802.15.3 无线城域网WMAN：IEEE 802.16","path":"2024/11/25/计算机网络/","date":"11-25","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Atcoder","text":"Atcoder主页：https://atcoder.jp 赛后补题：https://kenkoooo.com/atcoder/#/table，https://atcoder.jp/contests/archive 顶部菜单栏 比赛界面 顶部菜单栏：","path":"2024/11/14/Atcoder/","date":"11-14","excerpt":"","tags":[{"name":"介绍","slug":"介绍","permalink":"http://example.com/tags/%E4%BB%8B%E7%BB%8D/"}]},{"title":"算法","text":"[TOC] 基础算法龟速乘&amp;快速幂1234567891011121314151617181920212223zint ksc(int a, int b, int p) &#123; int ans = 0;//快速成是加法 while (b &gt; 0) &#123; if (b &amp; 1) &#123; ans = (ans + a) % p; &#125; b &gt;&gt;= 1; a = (a + a) % p; &#125; return ans;&#125;int ksm(int a,int b,int p)//快速幂&#123; int ans = 1;//快速幂的乘法 while (b &gt; 0) &#123; if (b &amp; 1) &#123; ans = ksc(ans, a, p) % p;//用快速乘代替原来的乘法运算 &#125; b &gt;&gt;= 1; a = ksc(a, a, p) % p; &#125; return ans;&#125; O(1)快速乘12345inline int mul(int x, int y, int MOD)&#123; x = x % MOD, y = y % MOD; return ((x * y - (int) (((LD) x * y + 0.5) / MOD) * MOD) % MOD + MOD) % MOD;&#125; 模乘优化b进制下,求 x mod m,默认大于0 m为k位数(b进制下),x位数小于等于2*k 123456789101112//b^n代表b的n次幂,mu=b^2k / m,可以预计算int BaRdc(int x, int b, int mu, int m, int k)&#123; int q1 = x / b ^ (k - 1);//右移k-1位,取整,后面同 int q2 = q1 * mu; int q3 = q2 / b ^ (k + 1);//移位 int r1 = x % b ^ (k + 1);//取低k位,因为mod m,m是k位的,所以只需看低k位即可 int r2 = (q3 * m) % b ^ (k + 1);//低k位 int r = r1 - r2;//低k位相减 if (r &gt; m) r -= m; return r;&#125; 欧拉筛1234567891011121314151617const int N = 1e6 + 5;int b[N], prime[N];int cnt;void init()&#123; memset(b, 1, sizeof(b)); b[0] = b[1] = 0; for (int i = 2; i &lt; N; i++) &#123; if (b[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt; N; j++)//质数的质数倍，保证不做重复运算 &#123; b[prime[j] * i] = 0;//标记为0，即为非质数 if (i % prime[j] == 0) break;//解释为i的最小素因子是prime[j]，但我猜测此时i==prime[j] &#125; &#125;&#125; 差分一维还原只需要对差分数组进行前缀和，变换只需要在 l 加 c ，r + 1 减 c 二维差分构造 1b[i][j]=a[i][j]+a[i-1][j-1]-a[i-1][j]-a[i][j-1]; 还原为二维前缀和 1234567for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j]; &#125; &#125; 变换为 1234b[x1][y1]+=c;b[x2+1][y1]-=c;b[x1][y2+1]-=c;b[x2+1][y2+1]+=c; 快读&amp;快写123456789101112131415161718192021222324252627int qread() &#123; int x = 0, y = 1; char c = getchar(); while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if (c == &#x27;-&#x27;) y = -1; c = getchar(); &#125; while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; c = getchar(); &#125; return x * y;&#125; /*//读取操作for (int i = 1; i &lt;= n; i++) &#123; arr[i] = readInt(); r = max(r, arr[i]);&#125;*/void write(int x) &#123; if(x&lt;0) putchar(&#x27;-&#x27;),x=-x; if(x&gt;9) write(x/10); putchar(x%10+&#x27;0&#x27;);&#125; 矩阵乘法多个矩阵相乘，其核心为尽可能用少的时间复杂度，可以考虑先算后面再进行前面的运算顺序 且其一般构造结构体进行存取 1234typedef long long LL;typedef struct &#123; LL m[MAX][MAX];&#125;Mit; 矩阵快速幂&#x2F;乘一般都用于求递推公式，将算出来的矩阵设为P，然后需要n阶单位矩阵I进行快速幂 结果一般用S接，然后计算 123456789101112131415161718192021222324252627Mit Mul(Mit a, Mit b)//快速乘&#123; Mit c; for (int i = 0; i &lt; MAX; i++) for (int j = 0; j &lt; MAX; j++) &#123; c.m[i][j] = 0; for (int k = 0; k &lt; MAX; k++) &#123; a.m[i][k] = (a.m[i][k] % MOD + MOD) % MOD; b.m[k][j] = (b.m[k][j] % MOD + MOD) % MOD; c.m[i][j] += (a.m[i][k] * b.m[k][j]) % MOD; &#125; c.m[i][j] = (c.m[i][j] % MOD + MOD) % MOD; &#125; return c;&#125;Mit qpow(Mit P, Mit I, int n)//快速幂&#123; Mit m = P, b = I; while (n &gt;= 1) &#123; if (n &amp; 1) &#123; b = Mul(b, m); &#125; n = n &gt;&gt; 1; m = Mul(m, m); &#125; return b;&#125; 高精度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186const int MAX = 100;struct hp &#123; int num[MAX]; hp &amp;operator=(const char *); hp &amp;operator=(int); hp(); hp(int); // 以下运算符可以根据实际需要来选择。 bool operator&gt;(const hp &amp;) const; bool operator&lt;(const hp &amp;) const; bool operator&lt;=(const hp &amp;) const; bool operator&gt;=(const hp &amp;) const; bool operator!=(const hp &amp;) const; bool operator==(const hp &amp;) const; hp operator+(const hp &amp;) const; hp operator-(const hp &amp;) const; hp operator*(const hp &amp;) const; hp operator/(const hp &amp;) const; hp operator%(const hp &amp;) const; hp &amp;operator+=(const hp &amp;); hp &amp;operator-=(const hp &amp;); hp &amp;operator*=(const hp &amp;); hp &amp;operator/=(const hp &amp;); hp &amp;operator%=(const hp &amp;);&#125;;// num[0]用来保存数字位数。另外，利用10000进制可以节省空间和时间。hp &amp;hp::operator=(const char *c)&#123; memset(num, 0, sizeof(num)); int n = strlen(c), j = 1, k = 1; for (int i = 1; i &lt;= n; i++) &#123; if (k == 10000) j++, k = 1; // 10000进制，4个数字才算1位。 num[j] += k * (c[n - i] - &#x27;0&#x27;); k *= 10; &#125; num[0] = j; return *this;&#125;hp &amp;hp::operator=(int a)&#123; char s[MAX]; sprintf(s, &quot;%d&quot;, a); return *this = s;&#125;hp::hp()&#123; memset(num, 0, sizeof(num)); num[0] = 1;&#125; // 目的：声明hp时无需显式初始化。hp::hp(int n) &#123; *this = n; &#125; // 目的：支持“hp a=1;”之类的代码。// 如果位数不等，大小是可以明显看出来的。如果位数相等，就需要逐位比较。bool hp::operator&gt;(const hp &amp;b) const&#123; if (num[0] != b.num[0]) return num[0] &gt; b.num[0]; for (int i = num[0]; i &gt;= 1; i--) if (num[i] != b.num[i]) return (num[i] &gt; b.num[i]); return false;&#125;bool hp::operator&lt;(const hp &amp;b) const &#123; return b &gt; *this; &#125;bool hp::operator&lt;=(const hp &amp;b) const &#123; return !(*this &gt; b); &#125;bool hp::operator&gt;=(const hp &amp;b) const &#123; return !(b &gt; *this); &#125;bool hp::operator!=(const hp &amp;b) const &#123; return (b &gt; *this) || (*this &gt; b); &#125;bool hp::operator==(const hp &amp;b) const &#123; return !(b &gt; *this) &amp;&amp; !(*this &gt; b); &#125;// 注意：最高位的位置和位数要匹配。hp hp::operator+(const hp &amp;b) const&#123; hp c; c.num[0] = max(num[0], b.num[0]); for (int i = 1; i &lt;= c.num[0]; i++) &#123; c.num[i] += num[i] + b.num[i]; if (c.num[i] &gt;= 10000) // 进位 &#123; c.num[i] -= 10000; c.num[i + 1]++; &#125; &#125; if (c.num[c.num[0] + 1] &gt; 0) c.num[0]++; // 9999+1，计算完成后多了一位 return c;&#125;hp hp::operator-(const hp &amp;b) const&#123; hp c; c.num[0] = num[0]; for (int i = 1; i &lt;= c.num[0]; i++) &#123; c.num[i] += num[i] - b.num[i]; if (c.num[i] &lt; 0) // 退位 &#123; c.num[i] += 10000; c.num[i + 1]--; &#125; &#125; while (c.num[c.num[0]] == 0 &amp;&amp; c.num[0] &gt; 1) c.num[0]--; // 100000000-99999999 return c;&#125;hp &amp;hp::operator+=(const hp &amp;b) &#123; return *this = *this + b; &#125;hp &amp;hp::operator-=(const hp &amp;b) &#123; return *this = *this - b; &#125;hp hp::operator*(const hp &amp;b) const&#123; hp c; c.num[0] = num[0] + b.num[0] + 1; for (int i = 1; i &lt;= num[0]; i++) &#123; for (int j = 1; j &lt;= b.num[0]; j++) &#123; c.num[i + j - 1] += num[i] * b.num[j]; // 和小学竖式的算法一模一样 c.num[i + j] += c.num[i + j - 1] / 10000; // 进位 c.num[i + j - 1] %= 10000; &#125; &#125; while (c.num[c.num[0]] == 0 &amp;&amp; c.num[0] &gt; 1) c.num[0]--; // 99999999*0 return c;&#125;hp &amp;hp::operator*=(const hp &amp;b) &#123; return *this = *this * b; &#125;hp hp::operator/(const hp &amp;b) const&#123; hp c, d; c.num[0] = num[0] + b.num[0] + 1; d.num[0] = 0; for (int i = num[0]; i &gt;= 1; i--) &#123; // 以下三行的含义是：d=d*10000+num[i]; memmove(d.num + 2, d.num + 1, sizeof(d.num) - sizeof(int) * 2); d.num[0]++; d.num[1] = num[i]; // 以下循环的含义是：c.num[i]=d/b; d%=b; while (d &gt;= b) &#123; d -= b; c.num[i]++; &#125; &#125; while (c.num[c.num[0]] == 0 &amp;&amp; c.num[0] &gt; 1) c.num[0]--; // 99999999/99999999 return c;&#125;hp hp::operator%(const hp &amp;b) const&#123; hp c, d; c.num[0] = num[0] + b.num[0] + 1; d.num[0] = 0; for (int i = num[0]; i &gt;= 1; i--) &#123; // 以下三行的含义是：d=d*10000+num[i]; memmove(d.num + 2, d.num + 1, sizeof(d.num) - sizeof(int) * 2); d.num[0]++; d.num[1] = num[i]; // 以下循环的含义是：c.num[i]=d/b; d%=b; while (d &gt;= b) &#123; d -= b; c.num[i]++; &#125; &#125; while (c.num[c.num[0]] == 0 &amp;&amp; c.num[0] &gt; 1) c.num[0]--; // 99999999/99999999 return d;&#125;hp &amp;hp::operator/=(const hp &amp;b) &#123; return *this = *this / b; &#125;hp &amp;hp::operator%=(const hp &amp;b) &#123; return *this = *this % b; &#125;ostream &amp;operator&lt;&lt;(ostream &amp;o, hp &amp;n)&#123; o &lt;&lt; n.num[n.num[0]]; for (int i = n.num[0] - 1; i &gt;= 1; i--) &#123; o.width(4); o.fill(&#x27;0&#x27;); o &lt;&lt; n.num[i]; &#125; return o;&#125;istream &amp;operator&gt;&gt;(istream &amp;in, hp &amp;n)&#123; char s[MAX]; in &gt;&gt; s; n = s; return in;&#125; 如果卡时常可以尝试二分优化除法和取模1234567891011121314151617181920212223242526272829hp hp::operator / (const hp&amp; b) const&#123; hp c, d; c.num[0] = num[0]+b.num[0]+1; d.num[0] = 0; for (int i=num[0];i&gt;=1;i--) &#123; // 以下三行的含义是：d=d*10000+num[i]; memmove(d.num+2, d.num+1, sizeof(d.num)-sizeof(int)*2); d.num[0]++; d.num[1]=num[i]; // 以下循环的含义是：c.num[i]=d/b; d%=b; 利用二分查找求c.num[i]的上界。 // 注意，这里是二分优化后除法和朴素除法的区别！ int left=0, right=9999, mid; while (left &lt; right) &#123; mid = (left+right)/2; if (b*hp(mid) &lt;= d) left=mid+1; else right=mid; &#125; c.num[i]=right-1; d=d-b*hp(right-1); &#125; while (c.num[c.num[0]]==0&amp;&amp;c.num[0]&gt;1) c.num[0]--; // 99999999/99999999 return c; // 求余数就改成return d;&#125; 位运算计算每一位可以用&gt;&gt;运算将数位后移到个位，进行与1位于运算可算出最后一位是否为1 树状数组 lowbit操作返回最后一位1，eg：10-&gt;1010，return 10-&gt;2 1234567891011121314//位运算&gt;&gt;while (a[i]) &#123; ans[i] += a[i] &amp; 1; a[i] = a[i] &gt;&gt; 1; &#125;//lowbitint lowbit(int x)&#123; return x &amp; -x;&#125;while (x) &#123; x = x - lowbit(x); ans++; &#125; 离散化1234567891011121314151617 vector&lt;int&gt; alls; // 存储所有待离散化的值 // 二分求出x对应的离散化的值 int find(int x) &#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; &#125;//main主函数sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 更加易写但难以理解的离散化： 1234567891011void work(int c[])&#123; for (int i = 1; i &lt;= n; i++) p[i] = i; sort(p + 1, p + n + 1, [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);//对下标进行排序 /*相当于bool cmp(int x, int y) &#123; return a[x] &lt; a[y]; &#125;*/ for (int i = 1; i &lt;= n; i++) a[p[i]] = i; //离散化处理&#125; 二分整数模板一：(用于check检验后答案为*******oxxxxxxx（其中o为答案，x为剩余区间）) 12345678910111213141516171819bool check(int k)&#123; &#125;int main()&#123; int l = 0, r = 1e9; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl;//有可能在l视情况定 return 0;&#125; 模板二：(用于check检验后答案为xxxxxo*****（其中o为答案，x为剩余区间）) 12345678910111213141516171819bool check(int k)&#123; &#125;int main()&#123; int l = 0, r = 1e9; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl;//有可能在l视情况定 return 0;&#125; 浮点数1234567891011121314151617double x;bool check(double k)&#123; return (k * k * k) &lt; x;//k即为二分结果，要求三次方根，即为k的三次方&#125;int main()&#123; l = -10000; r = 10000; while (r - l &gt; 1e-8)//这里1e-8为精度，一般比要求多2 &#123; double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; &#125; printf(&quot;%.6lf\\n&quot;, l);&#125; 三分12345678910111213141516171819LL check(int k)&#123; &#125;int main()&#123; int l = 0, r = 1e9; while (l &lt;= r) &#123; int midl = l + (r - l) / 3; int midr = r - (r - l) / 3; if (check(midl) &lt;= check(midr)) &#123; r = midr - 1; &#125; else l = midl + 1; &#125; cout &lt;&lt; (LL) min(check(l), check(r)) &lt;&lt; endl; return 0;&#125; 双指针12345for (int i = 0, j = 0; i &lt; n; i ++ ) &#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; //check表示题目的判断条件，没必要一定写函数，一般都是一个for里面套一个while，for里面接具体逻辑 &#125; 归并排序求逆序对数量12345678910111213141516171819int merge_sort(int l, int r)&#123; if (l == r) return 0; int ans = 0; int mid = l + r &gt;&gt; 1; ans = (merge_sort(l, mid) + merge_sort(mid + 1, r)) % MOD; int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (b[i] &lt;= b[j]) p[++k] = b[i++]; else &#123; ans = (ans + mid - i + 1) % MOD; p[++k] = b[j++]; &#125; &#125; while (i &lt;= mid) p[++k] = b[i++]; while (j &lt;= r) p[++k] = b[j++]; for (int i = l, j = 1; i &lt;= r; i++, j++) b[i] = p[j]; return ans;&#125; 康托展开时间复杂度O(n^2) 123456789101112131415int cantor(int n, int *a)//n为排列长度，a为排列结果数组&#123; int i, j; int ans = 1, s; for (i = 1; i &lt; n; ++i) &#123; s = 0; for (j = i + 1; j &lt;= n; ++j) &#123; if (a[j] &lt; a[i]) &#123; ++s; &#125; &#125; ans += s * f[n - i];//f为阶乘数组 &#125; return ans;&#125; 逆康托 123456789101112131415vector&lt;char&gt; vec; //存需要排列的字符void rev_cantor(int k) //输出序号为 k 的字符序列&#123; int n = vec.size(), len = 0; string ans = &quot;&quot;; k--; // 算的时候是按 12345 是第0位 for(int i = 1; i &lt;= n; i++)&#123; int t = k / f[n - i]; // 第 i 位需要 第 t + 1 大的数 k %= f[n - i]; //剩下的几位需要提供的排列数 ans += vec[t] ; // vec[t] 就是第 t + 1 大的数 vec.erase(vec.begin() + t);//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小 &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; 线段树维护康托展开，时间复杂度O(nlogn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 1000100#define Mod 998244353int T[MAXN &lt;&lt; 1];int query[MAXN], f[MAXN], N, K, i, j, q;inline void push_up(int rt)&#123; T[rt] = T[rt &lt;&lt; 1] + T[rt &lt;&lt; 1 | 1];&#125;inline void update(int rt, int l, int r, int p)&#123; if (l == p &amp;&amp; r == p) &#123; T[rt]++; return; &#125; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) update(rt &lt;&lt; 1, l, mid, p); else update(rt &lt;&lt; 1 | 1, mid + 1, r, p); push_up(rt);&#125;inline int que(int rt, int l, int r, int ql, int qr)&#123; if (ql &gt; qr) return 0; if (ql &lt;= l &amp;&amp; qr &gt;= r) return T[rt]; int mid = (l + r) &gt;&gt; 1, res = 0; if (ql &lt;= mid) res += que(rt &lt;&lt; 1, l, mid, ql, qr); if (qr &gt; mid) res += que(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res;&#125;inline void work_contor(int *now)&#123; int k, l, t = 0, res = 0; for (k = 1; k &lt;= N; ++k, t = 0) &#123; res = (1ll * res + 1ll * (now[k] - que(1, 1, N, 1, now[k] - 1) - 1) * f[N - k]) % Mod; update(1, 1, N, now[k]); &#125; cout &lt;&lt; (res + 1) % Mod &lt;&lt; endl;&#125;int main()&#123; cin &gt;&gt; N; f[1] = f[0] = 1; for (i = 2; i &lt;= N; i++) f[i] = 1ll * f[i - 1] * i % Mod; for (j = 1; j &lt;= N; j++) scanf(&quot;%d&quot;, &amp;query[j]); work_contor(query); return 0;&#125; 原根求最小原根 123456789101112131415161718192021222324252627282930313233343536373839404142434445int n, m;vector&lt;int&gt; factor;vector&lt;int&gt; get_factor(int n)//因子分解&#123; vector&lt;int&gt; res; for (int i = 1; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; res.push_back(i); if (i != n / i) &#123; res.push_back(n / i); &#125; &#125; &#125; return res;&#125;int ksm(int a, int b, int c)&#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a * a % c; &#125; return ans;&#125;signed main()&#123; cin &gt;&gt; n; int phi_m = n - 1; factor = get_factor(phi_m); for (int i = 2; i &lt; n; ++i) &#123; bool flag = 1; for (int j = 0; j &lt; factor.size(); ++j) &#123; if (factor[j] != phi_m &amp;&amp; ksm(i, factor[j], n) == 1) &#123; flag = 0; break; &#125; &#125; if (flag) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 求所有原根 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const int N = 1e6 + 5;int a[N], ans[N], n, r, t;int prime[N], b[N], phi[N];int cnt;void init()//欧拉筛法&#123; phi[1] = 1;//第一种情况 memset(b, 1, sizeof(b)); b[0] = b[1] = 0; for (int i = 2; i &lt; N; i++) &#123; if (b[i]) &#123; prime[++cnt] = i; phi[i] = i - 1;//第四种情况 &#125; for (int j = 1; prime[j] * i &lt; N &amp;&amp; j &lt;= cnt; j++) &#123; b[prime[j] * i] = 0; if (i % prime[j] == 0) &#123; phi[prime[j] * i] = phi[i] * prime[j];//第二种情况 break; &#125; phi[prime[j] * i] = phi[i] * (prime[j] - 1);//第三种情况 &#125; &#125;&#125;int gcd(int a, int b)&#123; return (b == 0) ? a : gcd(b, a % b);&#125;int ksm(int a, int b, int c)&#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ans;&#125;int check(int n)&#123; if (n % 2 == 0) return -1; if (!b[n]) return n; for (int i = 2; prime[i] * prime[i] &lt;= n; i++) if (n % prime[i] == 0) &#123; while (n % prime[i] == 0) n /= prime[i]; if (n &gt; 1) return -1; else return prime[i]; &#125; return -1;&#125;bool solve(int g, int mo)&#123; if (gcd(g, mo) != 1) return 0; for (int i = 1; i &lt;= r; i++) if (ksm(g, phi[mo] / a[i], mo) == 1) return 0; return 1;&#125;int getg(int mo)&#123; int n = phi[mo]; r = 0; for (int i = 1; prime[i] * prime[i] &lt;= n; i++) if (n % prime[i] == 0) &#123; while (n % prime[i] == 0) n /= prime[i]; a[++r] = prime[i]; &#125; if (n &gt; 1) a[++r] = n; for (int i = 2; i &lt; mo; i++) if (solve(i, mo)) return i;&#125;signed main()&#123; init(); while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; if (n == 2) &#123; puts(&quot;1&quot;); continue; &#125; if (n == 4) &#123; puts(&quot;3&quot;); continue; &#125; int ch = (n % 2 == 1) ? check(n) : check(n / 2); if (ch == -1) &#123; puts(&quot;-1&quot;); continue; &#125; int g = getg(n); int l = 0; for (int i = 1; i &lt;= phi[n]; i++) if (gcd(i, phi[n]) == 1) ans[++l] = ksm(g, i, n); sort(ans + 1, ans + 1 + l); for (int i = 1; i &lt;= l; i++) &#123; printf(&quot;%d&quot;, ans[i]); if (i == l) puts(&quot;&quot;); else printf(&quot; &quot;); &#125; &#125;&#125; 数论区间筛切记区间筛的范围为[a,b) 1234567891011121314151617181920212223242526272829303132typedef long long LL;const int N = 1e6;bool b[N + 5];//a到b的素数判断bool bprime[N + 5];//0到sqrt(b)的素数判断数组LL prime[N + 5];//a到b的素数数组LL isprime[N + 5];//0到sqrt(b)的素数数组LL p;LL cnt;void init(LL l, LL r)&#123; memset(b, 1, sizeof(b)); memset(bprime, 1, sizeof(bprime)); for (LL i = 2; i * i &lt; r; i++) &#123; if (bprime[i]) &#123; isprime[++cnt] = i; for (LL j = max(2LL, (l + i - 1) / i) * i; j &lt;= r; j += i) &#123; b[j - l + 1] = 0; //2LL是2的长整型形式 // max用于把((a+i-1)/i)*i)和最小素数2进行比较，一般是((a+i-1)/i)*i)，但是但a是1就是2了，它保证删除的都是素数的倍数 // ((a+i-1)/i)*i)当a为1时，如果没有最大值判定，那么j就是1，会把所有数字删掉 // 右移回到a，b区间进行判断，判断成功左移回来赋值false &#125; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * isprime[j] &lt;= N; j++) &#123;//正常欧拉筛写法 bprime[i * isprime[j]] = 0; if (i % isprime[j] == 0) break; &#125; &#125; for (LL i = 1; i &lt;= r - l; i++) &#123;//找到了所有a到b的素数，把素数放进素数表中 if (b[i]) prime[++p] = i + l - 1;//注意这里如果l是1的话会把1算作素数 &#125;&#125; 区间计数一般使用差分数组计算 区间合并（将带使用区间存入segs数组中） 12345678910111213141516171819202122232425262728void merge(vector&lt;PII&gt; &amp;segs) &#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end());//sort排序pair优先排序左端 int st = -2e9, ed = -2e9;//边界 for (auto seg : segs) if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); if (st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res; &#125;/*typedef pair&lt;int, int&gt; PII;vector&lt;PII&gt; vis;int main()&#123; vis.push_back(&#123; l,r &#125;); merge(vis);&#125;*/ 约数将一个数质因子分解为$$ p1^{a1}p2^{a2}…*pk^{ak} $$ 1 约数个数约数的个数为(a1+1)(a2+1)..*(ak+1) 记得头文件，bits中没有 1234567891011121314151617181920212223242526#include &lt;unordered_map&gt;typedef long long LL;unordered_map&lt;LL, LL&gt;sva;//内部自带哈希，但其头文件不在万能头文件中const int MOD = 1e9 + 7;int main()&#123; int n; cin &gt;&gt; n; while (n--) &#123; int a; cin &gt;&gt; a; for (int i = 2; i &lt;= a / i; i++) &#123;//质因子分解过程 while (a % i == 0) &#123; a /= i; sva[i]++; &#125; &#125; if (a &gt; 1) sva[a]++; &#125; LL res = 1; for (auto tmp : sva) &#123; res = (res * (tmp.second + 1)) % MOD; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 素数检验1234567891011121314151617181920212223242526272829303132333435LL Rand() &#123;//决定了程序的性能 static LL x = (srand((int)time(0)), rand()); x += 1000003; if (x &gt; 1000000007) x -= 1000000007; return x;&#125;bool Witness(LL a, LL n) &#123; LL t = 0, u = n - 1; while (!(u &amp; 1)) u &gt;&gt;= 1, t++; LL x = ksm(a, u, n), y; while (t--) &#123; y = x * x % n; if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return true; x = y; &#125; return x != 1;&#125;bool MillerRabin(LL n, LL s) &#123;//s为检验次数 if (n == 2 || n == 3 || n == 5) return 1; if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) return 0; while (s--) &#123; if (Witness(Rand() % (n - 1) + 1, n)) return false; &#125; return true;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import randomimport time def qread(): x = 0 y = 1 c = input() while not c.isdigit(): if c == &#x27;-&#x27;: y = -1 c = input() x = int(c) * y return x def write(x): if x &lt; 0: print(&#x27;-&#x27;, end=&#x27;&#x27;) x = -x if x &gt; 9: write(x // 10) print(x % 10, end=&#x27;&#x27;) def ksc(a, b, c): ans = 0 while b: if b &amp; 1: ans = (ans + a) % c b &gt;&gt;= 1 a = (a + a) % c return ans def ksm(a, b, c): ans = 1 while b: if b &amp; 1: ans = ksc(ans, a, c) b &gt;&gt;= 1 a = ksc(a, a, c) return ans def Rand(): global x x += 1000003 if x &gt; 1000000007: x -= 1000000007 return x def Witness(a, n): t = 0 u = n - 1 while not u &amp; 1: u &gt;&gt;= 1 t += 1 x = ksm(a, u, n) while t: y = x * x % n if y == 1 and x != 1 and x != n - 1: return True x = y t -= 1 return x != 1 def MillerRabin(n, s): if n == 2 or n == 3 or n == 5: return True if n % 2 == 0 or n % 3 == 0 or n % 5 == 0 or n == 1: return False while s: if Witness(random.randint(1, n - 1), n): return False s -= 1 return True if __name__ == &quot;__main__&quot;: y=10**30+50 print(y) x = qread() write(x) print() while not MillerRabin(x, 10): x += 1 write(x) Pollard Rho算法分解质因数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int S = 20;//随机算法判定次数，S越大，判错概率越小LL ksc(LL a, LL b, LL p)&#123; LL ans = 0;//快速成是加法 while (b &gt; 0) &#123; if (b &amp; 1) &#123; ans = (ans + a) % p; &#125; b &gt;&gt;= 1; a = (a + a) % p; &#125; return ans;&#125;LL ksm(LL a, LL b, LL p)//快速幂&#123; LL ans = 1;//快速幂的乘法 while (b &gt; 0) &#123; if (b &amp; 1) &#123; ans = ksc(ans, a, p) % p;//用快速乘代替原来的乘法运算 &#125; b &gt;&gt;= 1; a = ksc(a, a, p) % p; &#125; return ans;&#125;//一定是合数返回true,不一定返回falsebool check(LL a, LL n, LL x, LL t)&#123; LL ret = ksm(a, x, n); LL last = ret; for (int i = 1; i &lt;= t; i++) &#123; ret = ksc(ret, ret, n); if (ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数 last = ret; &#125; if (ret != 1) return true; return false;&#125;// Miller_Rabin()算法素数判定//是素数返回true.(可能是伪素数，但概率极小)//合数返回false;bool Miller_Rabin(LL n)&#123; if (n &lt; 2)return false; if (n == 2)return true; if ((n &amp; 1) == 0) return false;//偶数 LL x = n - 1; LL t = 0; while ((x &amp; 1) == 0) &#123; x &gt;&gt;= 1; t++; &#125; for (int i = 0; i &lt; S; i++) &#123; LL a = rand() % (n - 1) + 1;//rand()需要stdlib.h头文件 if (check(a, n, x, t)) return false;//合数 &#125; return true;&#125;//pollard_rho 算法进行质因数分解LL factor[100];//质因数分解结果（刚返回时是无序的）int tol;//质因数的个数。数组小标从0开始LL gcd(LL a, LL b)&#123; if (a == 0)return 1;//??????? if (a &lt; 0) return gcd(-a, b); while (b) &#123; LL t = a % b; a = b; b = t; &#125; return a;&#125;LL Pollard_rho(LL x, LL c)&#123; LL i = 1, k = 2; //i和k分别表示x0和y的前进距离，距离不同却相等说明有环 LL x0 = rand() % x; LL y = x0; while (1) &#123; i++; x0 = (ksc(x0, x0, x) + c) % x; LL d = gcd(y - x0, x); if (d != 1 &amp;&amp; d != x) return d; if (y == x0) return x; if (i == k) &#123; y = x0; k += k; &#125; &#125;&#125;//对n进行素因子分解void findfac(LL n)&#123; if (Miller_Rabin(n))//素数 &#123; factor[tol++] = n; return; &#125; LL p = n; while (p &gt;= n)p = Pollard_rho(p, rand() % (n - 1) + 1); findfac(p); findfac(n / p);&#125;LL num;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; tol = 0; cin &gt;&gt; num; if (Miller_Rabin(num)) &#123; cout &lt;&lt; &quot;Prime&quot; &lt;&lt; endl; &#125; else &#123; findfac(num); for (int i = 0; i &lt; tol; i++) cout &lt;&lt; factor[i] &lt;&lt; endl; &#125; &#125; return 0;&#125; 整除分块求$$\\sum_{i&#x3D;1}^{n} \\left \\lfloor \\frac{n}{i} \\right \\rfloor$$ 12345int ans = 0;for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans += n / l * (r - l + 1);&#125; 求$$\\sum_{i&#x3D;1}^{n} f(i)\\left \\lfloor \\frac{n}{i} \\right \\rfloor$$ 需要预处理出f(x)的前缀和数组，再进行分块求和 1234for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans += (sum[r] - sum[l - 1]) * (n / l); &#125; 莫比乌斯函数计算求单个值123456789101112131415int n;cin &gt;&gt; n;int ans = 1;for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; if (n % (i * i) == 0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; while (n % i == 0) n /= i; ans *= (-1); &#125;&#125;if (n) ans *= (-1);cout &lt;&lt; ans &lt;&lt; endl; 筛法求值12345678910111213141516171819202122const int N = 1e4 + 5;const int max1 = 1e4;int b[N], prime[N], mo[N];int cnt;void init()&#123; memset(b, 1, sizeof(b)); b[0] = b[1] = 0; mo[1] = 1; for (int i = 2; i &lt;= max1; i++) &#123; if (b[i]) &#123; prime[++cnt] = i; mo[i] = -1;//质数的莫比乌斯函数值为-1 &#125; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= max1; j++)//质数的质数倍，保证不做重复运算 &#123; b[prime[j] * i] = 0;//标记为0，即为非质数 if (i % prime[j] == 0) break;//解释为i的最小素因子是prime[j]，但我猜测此时i==prime[j] mo[prime[j] * i] = -mo[i];//由于prime[j]是质数且i不是prime[j]整数倍，所以就会多出一个质数，即变为相反 &#125; &#125;&#125; 欧拉函数计算求单个值123456789101112int a;while (cin &gt;&gt; a) &#123; int ans = a; for (int i = 2; i * i &lt;= a; i++) &#123;//寻找素因子 if (a % i == 0) &#123; ans = ans / i * (i - 1);//由于使用公式会出现小数，所以对原公式进行变形 while (a % i == 0) a /= i; &#125; &#125; if (a &gt; 1) ans = ans / a * (a - 1); cout &lt;&lt; ans &lt;&lt; endl;&#125; 筛法求值基于欧拉筛 1234567891011121314151617181920212223const int N = 1e6 + 5;int prime[N], b[N], phi[N];int cnt;void init()//欧拉筛法&#123; phi[1] = 1;//第一种情况 memset(b, 1, sizeof(b)); b[0] = b[1] = 0; for (int i = 2; i &lt; N; i++) &#123; if (b[i]) &#123; prime[++cnt] = i; phi[i] = i - 1;//第四种情况 &#125; for (int j = 1; prime[j] * i &lt; N &amp;&amp; j &lt;= cnt; j++) &#123; b[prime[j] * i] = 0; if (i % prime[j] == 0) &#123; phi[prime[j] * i] = phi[i] * prime[j];//第二种情况 break; &#125; phi[prime[j] * i] = phi[i] * (prime[j] - 1);//第三种情况 &#125; &#125;&#125; 和式的变换和式的变换主要有几个核心公式 1.交换律，结合律 $$2. \\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}\\sum_{d\\mid gcd(i,j))}d&#x3D;\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}\\sum_{d&#x3D;1}^{n}\\left [ d \\mid i\\right] \\left [ d\\mid j \\right ]d$$ $$3.\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}\\left [ gcd(i,j)&#x3D;k \\right ]&#x3D;\\sum_{ik&#x3D;1}^{n}\\sum_{jk&#x3D;1}^{m}\\left [ gcd(ik,jk)&#x3D;k \\right ]&#x3D;\\sum_{i&#x3D;1}^{\\frac{n}{k}}\\sum_{j&#x3D;1}^{\\frac{m}{k}}\\left [ gcd(i,j)&#x3D;1 \\right ]$$ $$4.\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}A(i)B(j)&#x3D;\\sum_{j&#x3D;1}^{m}\\sum_{i&#x3D;1}^{n}A(i)B(j)$$ $$5. \\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}A(i)B(j)&#x3D;\\sum_{i&#x3D;1}^{n}A(i)\\sum_{j&#x3D;1}^{m}B(j)$$ 其中[ ]为示性函数，符合条件的为1 常见变换式： $$1.\\left [ gcd(i,j)&#x3D;1 \\right ]&#x3D;\\sum_{d\\mid gcd(i,j))}\\mu (d)$$ 同时这个式子也是莫比乌斯反演的常用式子 $$2.d\\mid gcd(i,j)\\rightarrow \\left [ d\\mid i \\right ]\\left [ d\\mid j \\right ]$$ $$3.\\sum_{i&#x3D;1}^{n}\\left [ d\\mid i \\right ]\\rightarrow \\left \\lfloor \\frac{n}{d} \\right \\rfloor$$ $$4.\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{m}\\left [ gcd(i,j)&#x3D;k \\right ]&#x3D;\\sum_{i&#x3D;1}^{\\frac{n}{k}}\\sum_{j&#x3D;1}^{\\frac{m}{k}}\\left [ gcd(i,j)&#x3D;1 \\right ]$$ 其中n&#x2F;k和m&#x2F;k为下取整但在代码中int会下取整所以没有标明 $$5.\\sum_{k&#x3D;1}^{n}\\sum_{d&#x3D;1}^{\\frac{n}{k}}\\mu (d)\\left \\lfloor \\frac{n}{kd} \\right \\rfloor\\left \\lfloor \\frac{m}{kd} \\right \\rfloor\\rightarrow \\sum_{k&#x3D;1}^{n}\\sum_{T&#x3D;1}^{n}\\mu (\\frac{T}{k})\\left \\lfloor \\frac{n}{T} \\right \\rfloor\\left \\lfloor \\frac{m}{T} \\right \\rfloor$$ 大部分不做这个变换而是在向函数传参时传n&#x2F;k为n 莫比乌斯反演狄利克雷卷积$$(f*g)(n)&#x3D;\\sum_{d \\mid n}^{}f(d)g(\\frac{n}{d})&#x3D;\\sum_{d\\mid n}^{}f(\\frac{n}{d})g(d)$$ 三个常用函数 1.元函数 $$\\varepsilon (n)&#x3D;\\left [ n&#x3D;1 \\right ]$$ 2.常数函数 $$1(n)&#x3D;1$$ 3.恒等函数 $$id(n)&#x3D;n$$ 常用的卷积关系 $$1.\\sum_{d\\mid n}^{}\\mu (d)&#x3D;\\left [ n&#x3D;1 \\right ]\\Leftrightarrow \\mu *1&#x3D;\\varepsilon$$ $$2.\\sum_{d\\mid n}^{}\\varphi (d)&#x3D;n\\Leftrightarrow \\varphi *1&#x3D;id$$ $$3.\\sum_{d\\mid n}^{}\\mu (d)\\frac{n}{d}&#x3D;\\varphi (n)\\Leftrightarrow \\mu * id&#x3D;\\varphi$$ 莫比乌斯反演公式为： $$f(n)&#x3D;\\sum_{d \\mid n}g(d)\\Leftrightarrow g(n)&#x3D;\\sum_{d \\mid n}^{}\\mu (d)f(\\frac{n}{d})$$ 但是经常使用的为 $$\\left [ gcd(i,j)&#x3D;1 \\right ]&#x3D;\\sum_{d\\mid gcd(i,j))}\\mu (d)$$ 欧拉反演欧拉反演只是莫比乌斯反演的一种特殊情况，求 $$\\sum_{i&#x3D;1}^{n} \\sum_{j&#x3D;1}^{m}gcd(i,j)$$ 经过欧拉反演可以得出 $$\\sum_{i&#x3D;1}^{n} \\sum_{j&#x3D;1}^{m}\\sum_{d&#x3D;1}^{n}[d\\mid i][d\\mid j]\\varphi (d)$$ 这比经过莫比乌斯反演得出的式子简洁许多 欧拉反演的式子： $$\\sum_{d\\mid n}^{n}\\varphi (d)&#x3D;n$$ 二项式反演一般在使用二项式反演时，为已知一个的具体表达式，求另一个 设 $$f(n)$$ 为至少（或至多）选定 $$n$$ 个的方案数， $$g(n)$$为恰好选定 $$n$$ 个的方案数 这类是g为恰好，f为至多 $$1.f(n)&#x3D;\\sum_{i&#x3D;0}^{n}\\binom{n}{i}g(i)\\Leftrightarrow g(n)&#x3D;\\sum_{i&#x3D;0}^{n}(-1)^{n-i}\\binom{n}{i}f(i)$$ $$2.f(n)&#x3D;\\sum_{i&#x3D;0}^{n}(-1)^{i}\\binom{n}{i}g(i)\\Leftrightarrow g(n)&#x3D;\\sum_{i&#x3D;0}^{n}(-1)^{i}\\binom{n}{i}f(i)$$ 这类是g为恰好，f为至少 $$3.f(n)&#x3D;\\sum_{i&#x3D;n}^{m}\\binom{i}{n}g(i)\\Leftrightarrow g(n)&#x3D;\\sum_{i&#x3D;n}^{m}(-1)^{i-n}\\binom{i}{n}f(i)$$ $$4.f(n)&#x3D;\\sum_{i&#x3D;n}^{m}(-1)^{i}\\binom{i}{n}g(i)\\Leftrightarrow g(n)&#x3D;\\sum_{i&#x3D;n}^{m}(-1)^{i}\\binom{i}{n}f(i)$$ $$5.f(n,m)&#x3D;\\sum_{i&#x3D;0}^{n}\\sum_{j&#x3D;0}^{m}\\binom{n}{i}\\binom{m}{j}g(i,j)\\Leftrightarrow g(n,m)&#x3D;\\sum_{i&#x3D;0}^{n}\\sum_{j&#x3D;0}^{m}(-1)^{n+m-i-j}\\binom{n}{i}\\binom{m}{j}f(i,j)$$ $$6.f(n,m)&#x3D;\\sum_{i&#x3D;0}^{n}\\sum_{j&#x3D;0}^{m}(-1)^{i+j}\\binom{n}{i}\\binom{m}{j}g(i,j)\\Leftrightarrow g(n,m)&#x3D;\\sum_{i&#x3D;0}^{n}\\sum_{j&#x3D;0}^{m}(-1)^{i+j}\\binom{n}{i}\\binom{m}{j}f(i,j)$$ $$7.f(n,m)&#x3D;\\sum_{i&#x3D;n}^{?}\\sum_{j&#x3D;m}^{?}\\binom{i}{n}\\binom{j}{m}g(i,j)\\Leftrightarrow g(n,m)&#x3D;\\sum_{i&#x3D;n}^{?}\\sum_{j&#x3D;m}^{?}(-1)^{i+j-n-m}\\binom{i}{n}\\binom{j}{m}f(i,j)$$ $$8.f(n,m)&#x3D;\\sum_{i&#x3D;n}^{?}\\sum_{j&#x3D;m}^{?}(-1)^{i+j}\\binom{i}{n}\\binom{j}{m}g(i,j)\\Leftrightarrow g(n,m)&#x3D;\\sum_{i&#x3D;n}^{?}\\sum_{j&#x3D;m}^{?}(-1)^{i+j-}\\binom{i}{n}\\binom{j}{m}f(i,j)$$ 杜教筛杜教筛的核心是狄利克雷卷积，运用狄利克雷卷积把积性函数的前缀和等运算优化到小于线性的时间复杂度 主要根据三个常用积性函数，构造g 杜教筛最好在初始化时，初始化2&#x2F;3大小的前缀和，否则大概T *公式：$\\ g(1)S(n) &#x3D; \\sum_{i&#x3D;1}^{n}{(fg)(i)}-\\sum_{i&#x3D;2}^{n}{g(i)S(\\frac{n}{i})} $ 1234567891011121314151617181920212223242526272829303132333435363738//特别注意Sphi和Smo均使用map存储，使用int一般使用杜教筛范围都在1e8-1e9间//欧拉函数前n项和int getphi(int n)&#123; if (n &lt; N) return sumphi[n];//筛好的前缀和 if (Sphi.count(n)) return Sphi[n];//记忆化 int ans = 1LL * n * (n + 1) / 2;//f * g的前缀和 for (int l = 2, r; l &lt;= n; l = r + 1) &#123;//数论分块 r = n / (n / l); ans -= (r - l + 1) * getphi(n / l); &#125; return Sphi[n] = ans;//记忆化&#125;//莫比乌斯函数前n项和int getmo(int n)&#123; if (n &lt; N) return summo[n]; if (Smo.count(n)) return Smo[n]; int ans = 1LL; for (int l = 2, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans -= (r - l + 1) * getmo(n / l); &#125; return Smo[n] = ans;&#125;//一般形式int GetSum(int n) &#123; // 算 f 前缀和的函数 if (n &lt; N) return f_sum(n);//f的前缀和 if (S.count(n)) return S[n];//记忆化,S为map定义 int ans = f_g_sum(n); // 算 f * g 的前缀和 // 以下这个 for 循环是数论分块 for (int l = 2, r; l &lt;= n; l = r + 1) &#123; // 注意从 2 开始 r = (n / (n / l)); ans -= (g_sum(r) - g_sum(l - 1)) * GetSum(n / l); // g_sum 是 g 的前缀和 // 递归 GetSum 求解 &#125; return S[n] = ans;&#125; 逆元逆元常用的有两种计算方法： 扩展欧几里得和费马小定理，其中exgcd在下文中有写。费马小定理前提为a与MOD互质，则逆元为ksm(a,MOD-2,MOD); 线性时间计算逆元123for (int i = 2; i &lt;= n; i++) &#123; inv[i] = MOD - (MOD / i * inv[MOD % i] % MOD) % MOD; &#125; 线性时间计算阶乘逆元1234//先计算出n!的逆元 for (int i = n - 1; i &gt;= 0; i--) &#123; inv[i] = inv[i + 1] * (i + 1) % MOD; &#125; 1-n的LCM对于1-n中所有数的lcm,其应该等于1-n中每个质数p的以p为底数对于n的对数次幂的累积 $\\ lcm &#x3D; \\prod p^{log_{p}{n}} $，log下取整 GCD和EXGCD12345678910111213141516171819202122int gcd(int a, int b)&#123; if (b == 0) return a; else return(gcd(b, a % b));&#125;void exgcd(int a, int b, int &amp;x, int &amp;y, int &amp;d)&#123; if (b == 0) &#123; x = 1; y = 0; d = a; return; &#125; exgcd(b, a % b, x, y, d); int t; t = x; x = y; y = t - (a / b) * y;&#125;//逆元算法if (d == 1) cout &lt;&lt; (x + b) % b &lt;&lt; endl;else cout &lt;&lt; &quot;没有\\n&quot;; 线性同余方程一般使用扩展欧几里得算法，对于ax+by&#x3D;d有解，d当且仅当是gcd(a,b)的倍数 123最小正整数解为：int t = b / d * x % m;int ans = (t % (m / d) + (m / d)) % (m / d); 12345678910111213141516171819202122//求解ax同余与b（mod m）int exgcd(int a, int b, int&amp; x, int&amp; y)&#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int main()&#123; int a, b, m; int x, y; cin &gt;&gt; a &gt;&gt; b &gt;&gt; m; int d = exgcd(a, m, x, y); if (b % d != 0) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; b / d * x % m &lt;&lt; endl;//x的值，证明没看懂 &#125;&#125; 扩展中国剩余定理 （线性同余方程组）12345678910111213141516171819202122232425262728293031323334353637int n, M, ans;int a[N], m[N];int ksc(int a, int b, int c)&#123; int ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % c; b &gt;&gt;= 1; a = (a + a) % c; &#125; return ans;&#125;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int excrt()&#123; M = m[1], ans = a[1]; for (int i = 2; i &lt;= n; i++) &#123; int p = ((a[i] - ans) % m[i] + m[i]) % m[i]; int x = 0, y = 0; int d = exgcd(M, m[i], x, y); if (p % d) return -1;//无解 x = ksc(x, p / d, m[i] / d); ans += x * M; M *= m[i] / d; ans = (ans % M + M) % M; &#125; return (ans % M + M) % M;&#125; BSGS（高次同余方程）给定正整数 $a,p$，求满足$a^x\\equiv b ( % p)$的最小非负整数$x$ 但a，p互质时可以使用bsgs，但a，p不互质时，需使用exbsgs 12345678910111213141516171819202122232425262728293031323334353637383940int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int bsgs(int a, int b, int p)&#123; if (1 % p == b % p) return 0; int k = sqrt(p) + 1; unordered_map&lt;int, int&gt; hash; for (int i = 0, j = b % p; i &lt; k; ++i) &#123; hash[j] = i; j = (int) j * a % p; &#125; int ak = 1; for (int i = 0; i &lt; k; ++i) ak = (int) ak * a % p; for (int i = 1, j = ak; i &lt;= k; ++i) &#123; if (hash.count(j)) return i * k - hash[j]; j = (int) j * ak % p; &#125; return -INF;&#125;int exbsgs(int a, int b, int p)&#123; b = (b % p + p) % p; if (1 % p == b % p) return 0; int x, y; int d = exgcd(a, p, x, y); if (d &gt; 1) &#123; if (b % d) return -INF; exgcd(a / d, p / d, x, y); return exbsgs(a, (int) b / d * x % (p / d), p / d) + 1; &#125; return bsgs(a, b, p);&#125; BSGS(进阶版)$$求解 x^a \\equiv b (% p)$$解法一：（BSGS） 设g为p的原根，根据原根的性质存在c，满足$ g^c\\equiv x $成立，同理存在 t ，满足$g^t\\equiv b$成立。 所以有： $(g^c)^a \\equiv b (%p) &lt;&#x3D;&gt; (g^a)^c \\equiv b (%p)$ 由于$g^a$ 已知，所以可以直接使用BSGS求解c，也就是一个特解 解法二：（EXGCD） 设g为p的原根，根据原根的性质存在c，满足$ g^c\\equiv x $成立，同理存在 t ，满足$g^t\\equiv b$成立。 所以有$ (g^c)^a \\equiv b (%p) $ 根据阶的性质有，$ac \\equiv t (% \\phi(p))$ ，可以使用exgcd求解c，也是一个特解 求全部解： 我们在已知一个特解$g^c$的情况下，我们要得到全部解 $∵ g^{\\phi(p)} \\equiv 1 \\pmod{p} $ ∴ $\\forall t \\in \\mathbb{Z}, x \\equiv g^{ca+at\\phi(p)} \\pmod{p} $ ∴ $ \\forall t \\in \\mathbb{Z} \\text{且} a \\mid t\\phi(p), x \\equiv g^{c+at\\phi(p)} \\pmod{p} $ ∵ $ a \\mid t\\phi(p) $ ∴ $ \\frac{\\gcd(a, \\phi(p))}{a} \\mid t $ ∴ $ t &#x3D; \\frac{\\gcd(a, \\phi(p))}{a} \\cdot i $ ∴ $全部的解为: \\forall i \\in \\mathbb{Z}, x \\equiv g^{c + \\frac{\\gcd(a, \\phi(p))}{\\phi(p)} \\cdot i} \\pmod{p} $ $解的个数为 \\gcd(a, \\phi(p))$ 高斯消元线性方程组123456789101112131415161718192021222324252627282930313233343536373839const int N = 200;const double eps = 1e-8;int n;double a[N][N];int gauss()&#123; int r, c;//行，列 for (c = 1, r = 1; c &lt;= n; c++) &#123; int t = r; for (int i = r; i &lt;= n; i++) &#123; if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; &#125; if (fabs(a[t][c]) &lt; eps) continue;//用于下面判断解的情况 for (int i = c; i &lt;= n + 1; i++) swap(a[t][i], a[r][i]); for (int i = n + 1; i &gt;= c; i--) a[r][i] /= a[r][c]; for (int i = r + 1; i &lt;= n; i++) &#123; if (fabs(a[i][c]) &gt; eps) &#123; for (int j = n + 1; j &gt;= c; j--) a[i][j] -= a[r][j] * a[i][c];//目的为了把第r的第c个数变为0 &#125; &#125; r++; &#125; if (r &lt;= n) &#123; for (int i = r; i &lt;= n; i++) &#123; if (fabs(a[i][n + 1]) &gt; eps) return 2;//无解，出现0 = b情况 &#125; return 1;//无穷多解 &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i + 1; j &lt;= n; j++) a[i][n + 1] -= a[i][j] * a[j][n + 1]; &#125; return 0;//有单组解&#125; /*for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%.2lf\\n&quot;, a[i][n + 1]); &#125;*/ 枚举自由变元版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int n;int a[N][N];int x[N];//答案数组int gauss()&#123; int r, c;//行，列 for (c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) &#123; if (a[i][c]) t = i; &#125; if (!a[t][c]) continue;//用于下面判断解的情况 for (int i = c; i &lt;= n; i++) swap(a[t][i], a[r][i]); for (int i = r + 1; i &lt; n; i++) &#123; if (a[i][c]) &#123; for (int j = n; j &gt;= c; j--) a[i][j] ^= a[r][j];//目的为了把第r的第c个数变为0 &#125; &#125; r++; &#125; if (r &lt; n) &#123; for (int i = r; i &lt; n; i++) &#123; if (a[i][n]) return INF;//无解，出现0 = b情况 &#125;// return n - r;//无穷多解，返回自由变元数 &#125; for (int i = 0, j; i &lt; n; i++)//主元非0（一定有，说不定什么时候就因为这个WA了） if (!a[i][i]) &#123; for (j = i + 1; j &lt; n; j++) if (a[i][j]) break; if (n == j) break; for (int r = 0; r &lt; n; r++) swap(a[r][i], a[r][j]); &#125; int res = INF; for (int j = 0; j &lt; (1 &lt;&lt; (n - r)); j++) &#123; int tmp = j; int p = n - 1; while (tmp) x[p--] = tmp % 2, tmp &gt;&gt;= 1; for (int i = r - 1; i &gt;= 0; i--) &#123; int tp = a[i][n];//记录常数项 for (int j = i + 1; j &lt; n; j++) &#123; if (a[i][j]) tp ^= a[i][j] * x[j];//回代 &#125; x[i] = tp; &#125; tmp = 0; for (int i = 0; i &lt; n; i++) tmp += x[i]; res = min(res, tmp); &#125; return res;&#125; 异或线性方程组异或形式则需把a数组改为int形式，在处理上改为异或 12345678910111213141516171819202122232425262728293031323334353637383940const int N = 200;int n;int a[N][N];int gauss()&#123; int r, c;//行，列 for (c = 1, r = 1; c &lt;= n; c++) &#123; int t = r; for (int i = r; i &lt;= n; i++) &#123; if (a[i][c]) t = i; &#125; if (!a[t][c]) continue;//用于下面判断解的情况 for (int i = c; i &lt;= n + 1; i++) swap(a[t][i], a[r][i]); for (int i = n + 1; i &gt;= c; i--) a[r][i] /= a[r][c]; for (int i = r + 1; i &lt;= n; i++) &#123; if (a[i][c]) &#123; for (int j = n + 1; j &gt;= c; j--) a[i][j] ^= a[r][j];//目的为了把第r的第c个数变为0 &#125; &#125; r++; &#125; if (r &lt;= n) &#123; for (int i = r; i &lt;= n; i++) &#123; if (a[i][n + 1]) return 2;//无解，出现0 = b情况 &#125; return 1;//无穷多解 &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i + 1; j &lt;= n; j++) a[i][n + 1] ^= a[i][j] * a[j][n + 1]; &#125; return 0;//有单组解&#125; /*for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d\\n&quot;, a[i][n + 1]); &#125;*/ 方程数和变量数不相等时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int a[N][N], x[N];//a 是系数矩阵和增广矩阵，x 是最后存放的解int equ, var;//equ 是系数阵的行数，var 是系数矩阵的列数（变量的个数）int free_num;inline int gcd(int a, int b) //最大公约数&#123; int t; while (b != 0) &#123; t = b; b = a % b; a = t; &#125; return a;&#125;inline int lcm(int a, int b) //最小公倍数&#123; return a * b / gcd(a, b);&#125;int gauss()&#123; int k, col = 0; //当前处理的列 for (k = 0; k &lt; equ &amp;&amp; col &lt; var; ++k, ++col) &#123; int max_r = k; for (int i = k + 1; i &lt; equ; ++i) if (a[i][col] &gt; a[max_r][col]) max_r = i; if (max_r != k) &#123; for (int i = k; i &lt; var + 1; ++i) swap(a[k][i], a[max_r][i]); &#125; if (a[k][col] == 0) &#123; k--; continue; &#125; for (int i = k + 1; i &lt; equ; ++i) &#123; if (a[i][col] != 0) &#123; int LCM = lcm(a[i][col], a[k][col]); int ta = LCM / a[i][col], tb = LCM / a[k][col]; if (a[i][col] * a[k][col] &lt; 0) tb = -tb; for (int j = col; j &lt; var + 1; ++j) a[i][j] = ((a[i][j] * ta) % 2 - (a[k][j] * tb) % 2 + 2) % 2; //a[i][j]只有0和1两种状态 &#125; &#125; &#125; for (int i = k; i &lt; equ; ++i)//注意 k 的值，k 代表系数矩阵值都为 0 的那些行的第 1 行 if (a[i][col]) return -1; // 无解返回 -1 //唯一解或者无穷解,k&lt;=var //var-k==0 唯一解；var-k&gt;0 无穷多解，自由解的个数=var-k for (int i = 0; i &lt; equ; ++i)//每一行主元素化为非零 if (!a[i][i]) &#123; int j; for (j = i + 1; j &lt; var; ++j) if (a[i][j]) break; if (j == var) break; for (int k = 0; k &lt; equ; ++k) swap(a[k][i], a[k][j]); &#125; // free_num=k; if (var - k &gt; 0) &#123;//无穷多解，先枚举解，然后用下面的回带代码进行回带；//这里省略了下面的回带的代码；不管唯一解和无穷解都可以回带，只不过无穷解回带时，默认为最后几个自由变元=0 而已。 return var - k; &#125; if (var - k == 0)//唯一解时 &#123; //下面是回带求解代码，当无穷多解时，最后几行为 0 的解默认为 0； for (int i = k - 1; i &gt;= 0; --i) //从消完元矩阵的主对角线非 0 的最后 1 行，开始往回带 &#123; int tmp = a[i][var] % 2; for (int j = i + 1; j &lt; var; ++j) //x[i]取决于 x[i+1]--x[var]啊，所以后面的解对前面的解有影响 if (a[i][j] != 0) tmp = (tmp - (a[i][j] * x[j]) % 2 + 2) % 2; //if (a[i][i]==0) x[i]=tmp; //最后的空行时，即无穷解得 //else x[i] = (tmp / a[i][i]) % 2; //上面的正常解 &#125; return 0; &#125;&#125; 高斯消元解模线性方程组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int a[N][N];//增广矩阵int x[N];//解集bool freeX[N];//标记是否为自由变元int GCD(int a, int b) &#123; return !b ? a : GCD(b, a % b); &#125;int LCM(int a, int b) &#123; return a / GCD(a, b) * b; &#125;int equ, var;//方程数和变量数int gauss()&#123; for (int i = 0; i &lt;= var; i++) &#123; x[i] = 0; freeX[i] = true; &#125; int col = 0; //当前处理的列 int row;//当前处理的行 for (row = 0; row &lt; equ &amp;&amp; col &lt; var; row++, col++) &#123; //枚举当前处理的行 int maxRow = row; //当前列绝对值最大的行 for (int i = row + 1; i &lt; equ; i++) //寻找当前列绝对值最大的行 if (abs(a[i][col]) &gt; abs(a[maxRow][col])) maxRow = i; if (maxRow != row) //与第row行交换 for (int j = row; j &lt; var + 1; j++) swap(a[row][j], a[maxRow][j]); if (a[row][col] == 0) &#123; //col列第row行以下全是0，处理当前行的下一列 row--; continue; &#125; for (int i = row + 1; i &lt; equ; i++) //枚举要删去的行 if (a[i][col] != 0) &#123; int lcm = LCM(abs(a[i][col]), abs(a[row][col])); int ta = lcm / abs(a[i][col]); int tb = lcm / abs(a[row][col]); if (a[i][col] * a[row][col] &lt; 0) //异号情况相加 tb = -tb; for (int j = col; j &lt; var + 1; j++) a[i][j] = ((a[i][j] * ta - a[row][j] * tb) % MOD + MOD) % MOD; &#125; &#125; for (int i = row; i &lt; equ; i++) if (a[i][col]) return -1;//无解 //无穷解: 在var*(var+1)的增广阵中出现(0,0,...,0)这样的行 if (row &lt; var) //返回自由变元数 return var - row;; for (int i = var - 1; i &gt;= 0; i--) &#123; int temp = a[i][var]; for (int j = i + 1; j &lt; var; j++) &#123; if (a[i][j] != 0) temp -= a[i][j] * x[j]; temp = (temp % MOD + MOD) % MOD; //取模 &#125; while (temp % a[i][i] != 0) //外层每次循环都是求a[i][i]，它是每个方程中唯一一个未知的变量 temp += MOD; //a[i][i]必须为整数，加上周期MOD x[i] = (temp / a[i][i]) % MOD; //取模 &#125; return 0;&#125; Debug12345678void Debug()&#123; for (int i = 0; i &lt; equ; i++) &#123; for (int j = 0; j &lt; var + 1; j++) cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;&#125; 高斯消元求行列式应用：矩阵树定理定义矩阵D，大小为n*n，其中$ d_{i,j}&#x3D; \\begin{cases} 0,&amp;\\text{i !&#x3D; j} \\点i的度,&amp;\\text{i&#x3D;&#x3D;j} \\end{cases} $ 定义矩阵A，为图G的邻接矩阵 定义矩阵C，$ C &#x3D; D-A$ 那么G的所有不同生成树的个数等于矩阵C的任意一个 n - 1 阶主子式的行列式的绝对值，其中 n - 1 阶主子式为去掉C中第 i 行以及第 i 列得到的行列式 注意去掉最后一行最后一列变成 n - 1阶主子式，即 n– First（模数允许计算逆元）1234567891011121314151617181920212223242526272829303132int n, m;int a[N][N];int ksm(int a, int b, int c)&#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a * a % c; &#125; return ans;&#125;int Gauss()&#123; int ans = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) if (!a[i][i] &amp;&amp; a[j][i]) &#123; ans = -ans; swap(a[i], a[j]); break; &#125; int inv = ksm(a[i][i], MOD - 2, MOD); for (int j = i + 1; j &lt;= n; j++) &#123; int temp = a[j][i] * inv; for (int k = i; k &lt;= n; k++) a[j][k] = a[j][k] - a[i][k] * temp; &#125; ans = ans * a[i][i]; &#125; return ans;&#125; Second（模数不允许计算逆元）1234567891011121314151617181920212223int a[N][N];int gauss(int n)&#123; int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; while (a[j][i]) &#123; //辗转相除 int t = a[i][i] / a[j][i]; for (int k = i; k &lt;= n; ++k) &#123; a[i][k] -= (a[j][k] * t) % MOD; a[i][k] = (a[i][k] % MOD + MOD) % MOD; swap(a[i][k], a[j][k]); &#125; ans *= -1; //行列式交换行 &#125; &#125; if (a[i][i] == 0)return 0; ans = (ans * a[i][i]) % MOD; &#125; return (ans % MOD + MOD) % MOD;&#125; pell方程设pell方程的最小正整数解 $ x_1 ,y_1$ 已知，那么可以构造出 $ \\left{\\begin{matrix}x_1 \\ y_1\\end{matrix}\\right} $ $ \\left { \\begin{matrix} x_1 &amp; dy_1 \\ y_1 &amp;x_1\\end{matrix}\\right} ^{n-1} $ &#x3D; $ \\left { \\begin{matrix} x_n \\ y_n \\end{matrix} \\right} $ 暴力法求最小解12345678910111213141516171819202122void pell(int &amp;a, int &amp;b, int d)&#123;//暴力寻找pell方程最小解 b = 1; while (true) &#123; a = (int) sqrt(d * b * b + 1); if (a * a - d * b * b == 1) break; b++; &#125;&#125;/* int d; cin &gt;&gt; d; int m = (int) sqrt((double) d); if (m * m == d) &#123;//d不能为完全平方数 cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; return; &#125; int a = 0, b = 0; pell(a, b, d);//暴力找到最小解 cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;*/ 连分数法求解123456789101112131415161718192021222324252627282930313233343536373839int a[200005];bool pell(int &amp;x, int &amp;y, int d)&#123; int m = (int) sqrt((double) d); if (m * m == d)//d不能为完全平方数 return false; //将d以连分数形式存储 int num = 0;//连分数数位 double sq = sqrt(d);//d的高精度根，相当于r0 a[num++] = m;//存储整数部分 int b = m;//当前整数部分 int c = 1;//连分数最终展开时的分母 double temp;//连分数展开时的每一项 do &#123; c = (d - b * b) / c; temp = (sq + b) / c; a[num++] = (int) (double (temp)); b = a[num - 1] * c - b; &#125; while (a[num - 1] != 2 * a[0]);//当有一位等于整数两倍时结束 //将连分数形式化为分子分母形式，即求p、q两个值 int p = 1, q = 0; for (int i = num - 2; i &gt;= 0; i--) &#123; int temp = p; p = q + p * a[i]; q = temp; &#125; if ((num - 1) % 2) &#123;//连分数长度为奇数时 x = 2 * p * p + 1; y = 2 * p * q; &#125; else &#123;//连分数长度为偶数时 x = p; y = q; &#125; return true;&#125; 迭代公式求前n个解12345x[1] = a, y[1] = b;//第一组解for (int i = 2; i &lt;= n; i++) &#123;//递推公式 x[i] = x[i - 1] * x[1] + d * y[i - 1] * y[1]; y[i] = x[i - 1] * y[1] + y[i - 1] * x[1];&#125; 插值拉格朗日插值给定n个点坐标，求f(k)的值 12345678910111213141516171819202122int n, m, k;struct Point &#123; int x, y;&#125; A[N];int inv(int x) &#123; return ksm(x, MOD - 2, MOD); &#125;int lagrange()&#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int s1 = A[i].y % MOD; int s2 = 1ll; for (int j = 1; j &lt;= n; ++j) &#123; if (i != j) &#123; s1 = s1 * (k - A[j].x) % MOD; s2 = s2 * (A[i].x - A[j].x) % MOD; &#125; &#125; ans += s1 * inv(s2) % MOD; &#125; return (ans % MOD + MOD) % MOD;&#125; 拉格朗日插值公式$$f(x)&#x3D;\\sum_{i&#x3D;1}^{n} f(x_i) \\prod_{i \\neq j} \\frac{x-x_j}{x_i-x_J}$$ 多项式卷积$$f(x) &#x3D; g(x) \\times h(x) &#x3D; \\sum_{i&#x3D;0}^{x} g(i)h(x-i)$$ 对应系数：$f_k&#x3D;\\sum_{i+j&#x3D;k}g_ih_j&#x3D;\\sum_{i&#x3D;0}^{k}a_ib_{k-i}$ 多项式FFT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const double PI = acos(-1);struct Complex &#123; double x, y; // 实部和虚部 x + yi Complex(double _x = 0.0, double _y = 0.0)&#123; x = _x; y = _y; &#125; Complex operator - (const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator + (const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator * (const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;// 进行FFT和IFFT前的反转变换void change(Complex y[], int len)&#123; int i, j, k; for (i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) &#123; swap(y[i], y[j]); &#125; k = len / 2; while (j &gt;= k) &#123; j -= k; k /= 2; &#125; if (j &lt; k) &#123; j += k; &#125; &#125; return;&#125;// FFT// len必须为2^k形式，这也就导致了在主函数中进行fft前需要使用while (len &lt; m + n + 1) len &lt;&lt;= 1;而在输出结果时需要len = m + n + 1;更改为正确的数值void fft(Complex y[], int len, int on)&#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) &#123; for (int i = 0; i &lt; len; i++) &#123; y[i].x /= len; &#125; &#125;&#125; NTTNTT使用了特殊模数代替了FFT中浮点的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//一个n项和一个m项求卷积typedef long long LL;const int p = 998244353, G = 3, Gi = 332748118;//这里的Gi是G的除法逆元const int N = 5000007;const double PI = acos(-1); int n, m;int res, ans[N];int len = 1;//int L;//二进制的位数int RR[N];LL a[N], b[N];inline int qread()&#123; int x = 0, y = 1; char c = getchar(); while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if (c == &#x27;-&#x27;) y = -1; c = getchar(); &#125; while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; c = getchar(); &#125; return x * y;&#125;LL ksm(LL a, LL b, LL p)&#123; LL ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;LL inv(LL x) &#123; return ksm(x, p - 2, p); &#125;void NTT(LL* A, int type)&#123; for (int i = 0; i &lt; len; ++i) if (i &lt; RR[i]) swap(A[i], A[RR[i]]); for (int mid = 1; mid &lt; len; mid &lt;&lt;= 1) &#123; LL wn = ksm(G, (p - 1) / (mid * 2), p); if (type == -1) wn = ksm(wn, p - 2, p); //如果超时了上面if这句话删掉，在下面的if(type == -1)里加上下面这个循环 /*for (int i = 1; i &lt; len / 2; i ++) swap(A[i], A[len - i]); */ for (int j = mid &lt;&lt; 1, pos = 0; pos &lt; len; pos += j) &#123; LL w = 1; for (int k = 0; k &lt; mid; ++k, w = (w * wn) % p) &#123; int x = A[pos + k], y = w * A[pos + mid + k] % p; A[pos + k] = (x + y) % p; A[pos + k + mid] = (x - y + p) % p; &#125; &#125; &#125; if (type == -1) &#123; LL limit_inv = inv(len); for (int i = 0; i &lt; len; ++i) A[i] = (A[i] * limit_inv) % p; &#125;&#125;//多项式乘法void poly_mul(LL* a, LL* b, int deg)&#123; for (len = 1, L = 0; len &lt;= deg; len &lt;&lt;= 1) L++; for (int i = 0; i &lt; len; ++i) &#123; RR[i] = (RR[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); &#125; NTT(a, 1); NTT(b, 1); for (int i = 0; i &lt; len; ++i) a[i] = a[i] * b[i] % p; NTT(a, -1);&#125; int main()&#123; n = qread(), m = qread(); for (int i = 0; i &lt;= n; ++i) a[i] = (qread() + p) % p;//取模 for (int i = 0; i &lt;= m; ++i) b[i] = (qread() + p) % p; poly_mul(a, b, n + m); for (int i = 0; i &lt;= n + m; ++i) printf(&quot;%d &quot;, a[i]); return 0;&#125; FWT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//给定长度为2^n的两个序列分别求or,and,xor的结果const int N = 50007, P = 998244353;int n, m; void add(int&amp; x, int y) &#123; (x += y) &gt;= P &amp;&amp; (x -= P);&#125;void sub(int&amp; x, int y) &#123; (x -= y) &lt; 0 &amp;&amp; (x += P);&#125;struct FWT &#123; int extend(int n) &#123; int N = 1; for (; N &lt; n; N &lt;&lt;= 1); return N; &#125; void FWTor(vector&lt;int&gt;&amp; a, bool rev) &#123; int n = a.size(); for (int l = 2, m = 1; l &lt;= n; l &lt;&lt;= 1, m &lt;&lt;= 1) &#123; for (int j = 0; j &lt; n; j += l) for (int i = 0; i &lt; m; i++) &#123; if (!rev) add(a[i + j + m], a[i + j]); else sub(a[i + j + m], a[i + j]); &#125; &#125; &#125; void FWTand(vector&lt;int&gt;&amp; a, bool rev) &#123; int n = a.size(); for (int l = 2, m = 1; l &lt;= n; l &lt;&lt;= 1, m &lt;&lt;= 1) &#123; for (int j = 0; j &lt; n; j += l) for (int i = 0; i &lt; m; i++) &#123; if (!rev) add(a[i + j], a[i + j + m]); else sub(a[i + j], a[i + j + m]); &#125; &#125; &#125; void FWTxor(vector&lt;int&gt;&amp; a, bool rev) &#123; int n = a.size(), inv2 = (P + 1) &gt;&gt; 1; for (int l = 2, m = 1; l &lt;= n; l &lt;&lt;= 1, m &lt;&lt;= 1) &#123; for (int j = 0; j &lt; n; j += l) for (int i = 0; i &lt; m; i++) &#123; int x = a[i + j], y = a[i + j + m]; if (!rev) &#123; a[i + j] = (x + y) % P; a[i + j + m] = (x - y + P) % P; &#125; else &#123; a[i + j] = 1LL * (x + y) * inv2 % P; a[i + j + m] = 1LL * (x - y + P) * inv2 % P; &#125; &#125; &#125; &#125; vector&lt;int&gt; Or(vector&lt;int&gt; a1, vector&lt;int&gt; a2) &#123; int n = max(a1.size(), a2.size()), N = extend(n); a1.resize(N), FWTor(a1, false); a2.resize(N), FWTor(a2, false); vector&lt;int&gt; A(N); for (int i = 0; i &lt; N; i++) A[i] = 1LL * a1[i] * a2[i] % P; FWTor(A, true); return A; &#125; vector&lt;int&gt; And(vector&lt;int&gt; a1, vector&lt;int&gt; a2) &#123; int n = max(a1.size(), a2.size()), N = extend(n); a1.resize(N), FWTand(a1, false); a2.resize(N), FWTand(a2, false); vector&lt;int&gt; A(N); for (int i = 0; i &lt; N; i++) A[i] = 1LL * a1[i] * a2[i] % P; FWTand(A, true); return A; &#125; vector&lt;int&gt; Xor(vector&lt;int&gt; a1, vector&lt;int&gt; a2) &#123; int n = max(a1.size(), a2.size()), N = extend(n); a1.resize(N), FWTxor(a1, false); a2.resize(N), FWTxor(a2, false); vector&lt;int&gt; A(N); for (int i = 0; i &lt; N; i++) A[i] = 1LL * a1[i] * a2[i] % P; FWTxor(A, true); return A; &#125;&#125; fwt; int main() &#123; scanf(&quot;%d&quot;, &amp;m); n = 1 &lt;&lt; m; vector&lt;int&gt; a1(n), a2(n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a1[i]); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a2[i]); vector&lt;int&gt; A; A = fwt.Or(a1, a2); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d%c&quot;, A[i], &quot; \\n&quot;[i == n - 1]); &#125; A = fwt.And(a1, a2); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d%c&quot;, A[i], &quot; \\n&quot;[i == n - 1]); &#125; A = fwt.Xor(a1, a2); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d%c&quot;, A[i], &quot; \\n&quot;[i == n - 1]); &#125; return 0;&#125; 多项式大全123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253//#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3000007;//N的大小要根据初始化决定，否则造成越界const int p = 998244353, gg = 3, ig = 332738118, img = 86583718;const int mod = 998244353;template &lt;typename T&gt;void read(T &amp;x)&#123; x = 0; int f = 1; register char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;if(ch == &#x27;-&#x27;)f = -1;ch = getchar();&#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;x = x * 10 + ch - &#x27;0&#x27;;ch = getchar();&#125; x *= f;&#125;int qpow(int a, int b)&#123; int res = 1; while(b) &#123; if(b &amp; 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;namespace Poly&#123; #define mul(x, y) (1ll * x * y &gt;= mod ? 1ll * x * y % mod : 1ll * x * y) #define minus(x, y) (1ll * x - y &lt; 0 ? 1ll * x - y + mod : 1ll * x - y) #define plus(x, y) (1ll * x + y &gt;= mod ? 1ll * x + y - mod : 1ll * x + y) #define ck(x) (x &gt;= mod ? x - mod : x)//取模运算太慢了 typedef vector&lt;int&gt; poly; const int G = 3;//根据具体的模数而定，原根可不一定不一样！！！ //一般模数的原根为 2 3 5 7 10 6 const int inv_G = qpow(G, mod - 2); int RR[N], deer[2][19][N], inv[N]; void init(const int t) &#123;//预处理出来NTT里需要的w和wn，砍掉了一个log的时间 for(int p = 1; p &lt;= t; ++ p) &#123; int buf1 = qpow(G, (mod - 1) / (1 &lt;&lt; p)); int buf0 = qpow(inv_G, (mod - 1) / (1 &lt;&lt; p)); deer[0][p][0] = deer[1][p][0] = 1; for(int i = 1; i &lt; (1 &lt;&lt; p); ++ i) &#123; deer[0][p][i] = 1ll * deer[0][p][i - 1] * buf0 % mod;//逆 deer[1][p][i] = 1ll * deer[1][p][i - 1] * buf1 % mod; &#125; &#125; inv[1] = 1; for(int i = 2; i &lt;= (1 &lt;&lt; t); ++ i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; &#125; int NTT_init(int n) &#123;//快速数论变换预处理 int limit = 1, L = 0; while(limit &lt;= n) limit &lt;&lt;= 1, L ++ ; for(int i = 0; i &lt; limit; ++ i) RR[i] = (RR[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); return limit; &#125; void NTT(poly &amp;A, int type, int limit) &#123;//快速数论变换 A.resize(limit); for(int i = 0; i &lt; limit; ++ i) if(i &lt; RR[i]) swap(A[i], A[RR[i]]); for(int mid = 2, j = 1; mid &lt;= limit; mid &lt;&lt;= 1, ++ j) &#123; int len = mid &gt;&gt; 1; for(int pos = 0; pos &lt; limit; pos += mid) &#123; int *wn = deer[type][j]; for(int i = pos; i &lt; pos + len; ++ i, ++ wn) &#123; int tmp = 1ll * (*wn) * A[i + len] % mod; A[i + len] = ck(A[i] - tmp + mod); A[i] = ck(A[i] + tmp); &#125; &#125; &#125; if(type == 0) &#123; for(int i = 0; i &lt; limit; ++ i) A[i] = 1ll * A[i] * inv[limit] % mod; &#125; &#125; poly poly_mul(poly A, poly B) &#123;//多项式乘法 int deg = A.size() + B.size() - 1; int limit = NTT_init(deg); poly C(limit); NTT(A, 1, limit); NTT(B, 1, limit); for(int i = 0; i &lt; limit; ++ i) C[i] = 1ll * A[i] * B[i] % mod; NTT(C, 0, limit); C.resize(deg); return C; &#125; poly poly_inv(poly &amp;f, int deg) &#123;//多项式求逆 if(deg == 1) return poly(1, qpow(f[0], mod - 2)); poly A(f.begin(), f.begin() + deg); poly B = poly_inv(f, (deg + 1) &gt;&gt; 1); int limit = NTT_init(deg &lt;&lt; 1); NTT(A, 1, limit), NTT(B, 1, limit); for(int i = 0; i &lt; limit; ++ i) A[i] = B[i] * (2 - 1ll * A[i] * B[i] % mod + mod) % mod; NTT(A, 0, limit); A.resize(deg); return A; &#125; poly poly_dev(poly f) &#123;//多项式求导 int n = f.size(); for(int i = 1; i &lt; n; ++ i) f[i - 1] = 1ll * f[i] * i % mod; return f.resize(n - 1), f;//f[0] = 0，这里直接扔了,从1开始 &#125; poly poly_idev(poly f) &#123;//多项式求积分 int n = f.size(); for(int i = n - 1; i ; -- i) f[i] = 1ll * f[i - 1] * inv[i] % mod; return f[0] = 0, f; &#125; poly poly_ln(poly f, int deg) &#123;//多项式求对数 poly A = poly_idev(poly_mul(poly_dev(f), poly_inv(f, deg))); return A.resize(deg), A; &#125; poly poly_exp(poly &amp;f, int deg) &#123;//多项式求指数 if(deg == 1) return poly(1, 1); poly B = poly_exp(f, (deg + 1) &gt;&gt; 1); B.resize(deg); poly lnB = poly_ln(B, deg); for(int i = 0; i &lt; deg; ++ i) lnB[i] = ck(f[i] - lnB[i] + mod); int limit = NTT_init(deg &lt;&lt; 1);//n -&gt; n^2 NTT(B, 1, limit), NTT(lnB, 1, limit); for(int i = 0; i &lt; limit; ++ i) B[i] = 1ll * B[i] * (1 + lnB[i]) % mod; NTT(B, 0, limit); B.resize(deg); return B; &#125; poly poly_sqrt(poly &amp;f, int deg) &#123;//多项式开方 if(deg == 1) return poly(1, 1); poly A(f.begin(), f.begin() + deg); poly B = poly_sqrt(f, (deg + 1) &gt;&gt; 1); poly IB = poly_inv(B, deg); int limit = NTT_init(deg &lt;&lt; 1); NTT(A, 1, limit), NTT(IB, 1, limit); for(int i = 0; i &lt; limit; ++ i) A[i] = 1ll * A[i] * IB[i] % mod; NTT(A, 0, limit); for(int i =0; i &lt; deg; ++ i) A[i] = 1ll * (A[i] + B[i]) * inv[2] % mod; A.resize(deg); return A; &#125; poly poly_pow(poly f, int k) &#123;//多项式快速幂 f = poly_ln(f, f.size()); for(auto &amp;x : f) x = 1ll * x * k % mod; return poly_exp(f, f.size()); &#125; poly poly_cos(poly f, int deg) &#123;//多项式三角函数（cos） poly A(f.begin(), f.begin() + deg); poly B(deg), C(deg); for(int i = 0; i &lt; deg; ++ i) A[i] = 1ll * A[i] * img % mod; B = poly_exp(A, deg); C = poly_inv(B, deg); int inv2 = qpow(2, mod - 2); for(int i = 0; i &lt; deg; ++ i) A[i] = 1ll * (1ll * B[i] + C[i]) % mod * inv2 % mod; return A; &#125; poly poly_sin(poly f, int deg) &#123;//多项式三角函数（sin） poly A(f.begin(), f.begin() + deg); poly B(deg), C(deg); for(int i = 0; i &lt; deg; ++ i) A[i] = 1ll * A[i] * img % mod; B = poly_exp(A, deg); C = poly_inv(B, deg); int inv2i = qpow(img &lt;&lt; 1, mod - 2); for(int i = 0; i &lt; deg; ++ i) A[i] = 1ll * (1ll * B[i] - C[i] + mod) % mod * inv2i % mod; return A; &#125; poly poly_arcsin(poly f, int deg) &#123; poly A(f.size()), B(f.size()), C(f.size()); A = poly_dev(f); B = poly_mul(f, f); for(int i = 0; i &lt; deg; ++ i) B[i] = minus(mod, B[i]); B[0] = plus(B[0], 1); C = poly_sqrt(B, deg); C = poly_inv(C, deg); C = poly_mul(A, C); C = poly_idev(C); return C; &#125; poly poly_arctan(poly f, int deg) &#123; poly A(f.size()), B(f.size()), C(f.size()); A = poly_dev(f); B = poly_mul(f, f); B[0] = plus(B[0], 1); C = poly_inv(B, deg); C = poly_mul(A, C); C = poly_idev(C); return C; &#125;&#125;using Poly::poly;using Poly::poly_arcsin;using Poly::poly_arctan;int n, m, x, k, type;poly f, g;char s[N];int main()&#123; Poly::init(18);//2^21 = 2,097,152,根据题目数据多项式项数的大小自由调整，注意大小需要跟deer数组同步(21+1=22),也就是init内的数字比deer数组的第二维少1，根据题目进行调整 read(n), read(type); for(int i = 0; i &lt; n; ++ i) read(x), f.push_back(x); if(type == 0) g = poly_arcsin(f, n); else g = poly_arctan(f, n); for(int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, g[i]); return 0;&#125; 多项式更快123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548/*namespace poly_base (变换基础)namespace poly (多项式初等函数)namespace CDQ_NTT (分治多项式技巧)namespace poly_evaluation (多点求值)namespace poly_interpolation (快速插值)namespace linear_recur (常系数线性齐次递推式 - Fiduccia)namespace linear_recur_single (常系数线性齐次递推式 - 单点)namespace miscellaneous (杂项)*/// This is a NEW polynomial template for C++11#include &lt;bits/stdc++.h&gt;#define EB emplace_back#define lg2 std::__lgtypedef unsigned long long u64;const int N = 530000, mod = 998244353, iv2 = (mod + 1) / 2, unity = 31;typedef int vec[N], *pvec;typedef std::pair &lt;int, int&gt; pr;typedef std::vector &lt;int&gt; vector;vec inv, fact, finv;inline int min(const int x, const int y) &#123;return x &lt; y ? x : y;&#125;inline int max(const int x, const int y) &#123;return x &lt; y ? y : x;&#125;inline int &amp; reduce(int &amp;x) &#123;return x += x &gt;&gt; 31 &amp; mod;&#125;inline int &amp; neg(int &amp;x) &#123;return x = (!x - 1) &amp; (mod - x);&#125;u64 PowerMod(u64 a, int n, u64 c = 1) &#123;for (; n; n &gt;&gt;= 1, a = a * a % mod) if (n &amp; 1) c = c * a % mod; return c;&#125;namespace poly_base &#123; int l, n; u64 iv; vec w2; void init(int n = N, bool dont_calc_factorials = true) &#123; int i, t; for (inv[1] = 1, i = 2; i &lt; n; ++i) inv[i] = u64(mod - mod / i) * inv[mod % i] % mod; if (!dont_calc_factorials) for (*finv = *fact = i = 1; i &lt; n; ++i) fact[i] = (u64)fact[i - 1] * i % mod, finv[i] = (u64)finv[i - 1] * inv[i] % mod; t = min(n &gt; 1 ? lg2(n - 1) : 0, 21), *w2 = 1, w2[1 &lt;&lt; t] = PowerMod(unity, 1 &lt;&lt; (21 - t)); for (i = t; i; --i) w2[1 &lt;&lt; (i - 1)] = (u64)w2[1 &lt;&lt; i] * w2[1 &lt;&lt; i] % mod; for (i = 1; i &lt; n; ++i) w2[i] = (u64)w2[i &amp; (i - 1)] * w2[i &amp; -i] % mod; &#125; inline void NTT_init(int len) &#123;n = 1 &lt;&lt; (l = len), iv = mod - (mod - 1) / n;&#125; void DIF(int *a) &#123; int i, *j, *k, len = n &gt;&gt; 1, R, *o; for (i = 0; i &lt; l; ++i, len &gt;&gt;= 1) for (j = a, o = w2; j != a + n; j += len &lt;&lt; 1, ++o) for (k = j; k != j + len; ++k) R = (u64)*o * k[len] % mod, reduce(k[len] = *k - R), reduce(*k += R - mod); &#125; void DIT(int *a) &#123; int i, *j, *k, len = 1, R, *o; for (i = 0; i &lt; l; ++i, len &lt;&lt;= 1) for (j = a, o = w2; j != a + n; j += len &lt;&lt; 1, ++o) for (k = j; k != j + len; ++k) reduce(R = *k + k[len] - mod), k[len] = u64(*k - k[len] + mod) * *o % mod, *k = R; &#125; inline void DNTT(int *a) &#123;DIF(a);&#125; inline void IDNTT(int *a) &#123; DIT(a), std::reverse(a + 1, a + n); for (int i = 0; i &lt; n; ++i) a[i] = a[i] * iv % mod; &#125; inline void DIF(int *a, int *b) &#123;memcpy(b, a, n &lt;&lt; 2), DIF(b);&#125; inline void DIT(int *a, int *b) &#123;memcpy(b, a, n &lt;&lt; 2), DIT(b);&#125; inline void DNTT(int *a, int *b) &#123;memcpy(b, a, n &lt;&lt; 2), DNTT(b);&#125; inline void IDNTT(int *a, int *b) &#123;memcpy(b, a, n &lt;&lt; 2), IDNTT(b);&#125;&#125;namespace poly &#123; using namespace poly_base; vec B1, B2, B3, B4, B5, B6; // Multiplication (use one buffer, 3-dft of length 2n) void mul(int deg, pvec a, pvec b, pvec c) &#123; if (!deg) &#123;*c = (u64)*a * *b % mod; return;&#125; NTT_init(lg2(deg) + 1), DNTT(a, c), DNTT(b, B1); for (int i = 0; i &lt; n; ++i) c[i] = (u64)c[i] * B1[i] % mod; IDNTT(c); &#125; // Inversion (use three buffers, 5-dft) void inv(int deg, pvec a, pvec b) &#123; int i, len; assert(*a); if (*b = PowerMod(*a, mod - 2), deg &lt;= 1) return; memset(b + 1, 0, i = 8 &lt;&lt; lg2(deg - 1)), memset(B1, 0, i), *B1 = *a; for (len = 0; 1 &lt;&lt; len &lt; deg; ++len) &#123; NTT_init(len + 1); memcpy(B1 + (n &gt;&gt; 1), a + (n &gt;&gt; 1), n &lt;&lt; 1), DIF(b, B2), DIF(B1, B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B2[i] % mod; DIT(B3); for (i = n &gt;&gt; 1; i &lt; n; ++i) B3[i] = B3[n - i] * iv % mod; memset(B3, 0, n &lt;&lt; 1), DIF(B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B2[i] % mod; DIT(B3); for (i = n &gt;&gt; 1; i &lt; n; ++i) b[i] = B3[n - i] * (mod - iv) % mod; &#125; &#125; // Division and Modulo Operation (use five buffers) void div_mod(int A, int B, pvec a, pvec b, pvec q, pvec r) &#123; if (A &lt; B) &#123;memcpy(r, a, (A + 1) &lt;&lt; 2), memset(r + (A + 1), 0, (B - A) &lt;&lt; 2); return;&#125; int Q = A - B, i, l_ = Q ? lg2(Q) + 1 : 0; NTT_init(l_); for (i = 0; i &lt;= Q &amp;&amp; i &lt;= B; ++i) B4[i] = b[B - i]; memset(B4 + i, 0, (n - i) &lt;&lt; 2), inv(i = Q + 1, B4, B5); std::reverse_copy(a + B, a + (A + 1), B4), NTT_init(++l_), memset(B4 + i, 0, (n - i) &lt;&lt; 2), memset(B5 + i, 0, (n - i) &lt;&lt; 2), mul(2 * Q, B4, B5, q), std::reverse(q, q + (Q + 1)), memset(q + i, 0, (n - i) &lt;&lt; 2); if (!B) return; NTT_init(lg2(2 * B - 1) + 1); for (i = 0; i &lt;= Q &amp;&amp; i &lt; B; ++i) B2[i] = b[i], B3[i] = q[i]; memset(B2 + i, 0, (n - i) &lt;&lt; 2), memset(B3 + i, 0, (n - i) &lt;&lt; 2), mul(2 * (B - 1), B2, B3, r), memset(r + i, 0, (n - i) &lt;&lt; 2); for (i = 0; i &lt; B; ++i) reduce(r[i] = a[i] - r[i]); &#125; // Multiplication with std::vector (use two buffers, 3-dft) void mul(vector &amp;a, vector &amp;b, vector &amp;ret) &#123; int A = a.size() - 1, B = b.size() - 1; if (!(A || B)) &#123;ret.EB((u64)a[0] * b[0] % mod); return;&#125; NTT_init(lg2(A + B) + 1), memcpy(B1, a.data(), (A + 1) &lt;&lt; 2), memset(B1 + (A + 1), 0, (n - A - 1) &lt;&lt; 2), memcpy(B2, b.data(), (B + 1) &lt;&lt; 2), memset(B2 + (B + 1), 0, (n - B - 1) &lt;&lt; 2), DNTT(B1), DNTT(B2); for (int i = 0; i &lt; n; ++i) B1[i] = (u64)B1[i] * B2[i] % mod; IDNTT(B1), ret.assign(B1, B1 + (A + B + 1)); &#125; // Differential void diff(int deg, pvec a, pvec b) &#123;for (int i = 1; i &lt;= deg; ++i) b[i - 1] = (u64)a[i] * i % mod;&#125; // Integral void intg(int deg, pvec a, pvec b, int constant = 0) &#123;for (int i = deg; i; --i) b[i] = (u64)a[i - 1] * ::inv[i] % mod; *b = constant;&#125; // f&#x27;[x] / f[x] (use four buffers, 6.5-dft) void dif_quo(int deg, pvec a, pvec b) &#123; assert(*a); if (deg &lt;= 1) &#123;*b = PowerMod(*a, mod - 2, a[1]); return;&#125; int i, len = lg2(deg - 1); inv((deg + 1) / 2, a, B4), NTT_init(len + 1), memset(B4 + (n &gt;&gt; 1), 0, n &lt;&lt; 1), DIF(B4, B2), diff(deg, a, B1), memcpy(B3, B1, n &lt;&lt; 1), memset(B3 + (n &gt;&gt; 1), 0, n &lt;&lt; 1), DIF(B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B2[i] % mod; DIT(B3, b), *b = *b * iv % mod; for (i = 1; i &lt; n &gt;&gt; 1; ++i) b[i] = b[n - i] * iv % mod; memset(b + (n &gt;&gt; 1), 0, n &lt;&lt; 1); DIF(b, B4), DIF(a, B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B4[i] % mod; DIT(B3); for (i = n &gt;&gt; 1; i &lt; n; ++i) B3[i] = (B3[n - i] * iv + mod - B1[i]) % mod; memset(B3, 0, n &lt;&lt; 1), DIF(B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B2[i] % mod; DIT(B3); for (i = n &gt;&gt; 1; i &lt; n; ++i) b[i] = B3[n - i] * (mod - iv) % mod; &#125; // Logarithm (use DifQuo) inline void ln(int deg, pvec a, pvec b) &#123;assert(*a == 1), --deg ? (dif_quo(deg, a, b), intg(deg, b, b)) : void(*b = 0);&#125; // Exponentiation (use six buffers, 12-dft) // WARNING : this implementation of exponentiation is SLOWER than the CDQ_NTT ver. void exp(int deg, pvec a, pvec b) &#123; int i, len; pvec c = B6; assert(!*a); if (*b = 1, deg &lt;= 1) return; if (b[1] = a[1], deg == 2) return; memset(b + 2, 0, i = 8 &lt;&lt; lg2(deg - 1)), memset(c, 0, i), memset(B1, 0, i), *c = 1, neg(c[1] = b[1]); for (len = 1; 1 &lt;&lt; len &lt; deg; ++len) &#123; NTT_init(len + 1); DIF(c, B2), DIF(b, B3); for (i = 0; i &lt; n; ++i) B4[i] = (u64)B3[i] * B2[i] % mod; DIT(B4); for (i = n &gt;&gt; 1; i &lt; n; ++i) B4[i] = B4[n - i] * iv % mod; memset(B4, 0, n &lt;&lt; 1), DIF(B4); for (i = 0; i &lt; n; ++i) B4[i] = (u64)B4[i] * B2[i] % mod; DIT(B4); for (i = n &gt;&gt; 1; i &lt; n; ++i) B4[i] = B4[n - i] * (mod - iv) % mod; memcpy(B4, c, n &lt;&lt; 1), DIF(B4); diff(n &gt;&gt; 1, b, B1), DIF(B1, B5); for (i = 0; i &lt; n; ++i) B4[i] = (u64)B4[i] * B5[i] % mod; DIT(B4); for (i = n &gt;&gt; 1; i &lt; n; ++i) reduce(B5[i] = (a[i] + B4[n - i + 1] * (mod - iv) % mod * ::inv[i]) % mod); memset(B5, 0, n &lt;&lt; 1), DIF(B5); for (i = 0; i &lt; n; ++i) B5[i] = (u64)B5[i] * B3[i] % mod; DIT(B5); for (i = n &gt;&gt; 1; i &lt; n; ++i) b[i] = B5[n - i] * iv % mod; if (2 &lt;&lt; len &gt;= deg) return; DIF(b, B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B2[i] % mod; DIT(B3); for (i = n &gt;&gt; 1; i &lt; n; ++i) B3[i] = B3[n - i] * iv % mod; memset(B3, 0, n &lt;&lt; 1), DIF(B3); for (i = 0; i &lt; n; ++i) B3[i] = (u64)B3[i] * B2[i] % mod; DIT(B3); for (i = n &gt;&gt; 1; i &lt; n; ++i) c[i] = B3[n - i] * (mod - iv) % mod; &#125; &#125;&#125;namespace CDQ_NTT &#123; using namespace poly_base; int lim; vec f, g, C1; int fn[N * 2], gn[N * 2]; inline void register_g(pvec g) &#123;for (int i = 1; 1 &lt;&lt; (i - 1) &lt;= lim; ++i) NTT_init(i), DIF(g, gn + (1 &lt;&lt; i));&#125; // Standard CDQ-NTT Algorithm, type `UK` void solve(int L, int w) &#123; int i, R = L + (1 &lt;&lt; w), M; if (!w) &#123; // something depend on problem return; &#125; solve(L, w - 1); if ((M = (1 &lt;&lt; (w - 1)) + L) &gt; lim) return; NTT_init(w); pvec ga = gn + (1 &lt;&lt; w); memcpy(C1, f + L, 2 &lt;&lt; w), memset(C1 + (1 &lt;&lt; (w - 1)), 0, 2 &lt;&lt; w), DIF(C1); for (i = 0; i &lt; n; ++i) C1[i] = (u64)C1[i] * ga[i] % mod; DIT(C1); for (i = M; i &lt; R; ++i) f[i] = (f[i] + C1[n - (i - L)] * iv) % mod; solve(M, w - 1); &#125; void solve(int L, int w) &#123; int i, R = L + (1 &lt;&lt; w), M; if (!w) &#123; // something depend on problem return; &#125; solve(L, w - 1); if ((M = (1 &lt;&lt; (w - 1)) + L) &gt; lim) return; NTT_init(w); if (L) &#123; pvec fa = fn + (1 &lt;&lt; w), ga = gn + (1 &lt;&lt; w); memcpy(C1, f + L, 2 &lt;&lt; w), memset(C1 + (1 &lt;&lt; (w - 1)), 0, 2 &lt;&lt; w), memcpy(C2, g + L, 2 &lt;&lt; w), memset(C2 + (1 &lt;&lt; (w - 1)), 0, 2 &lt;&lt; w), DIF(C1), DIF(C2); for (i = 0; i &lt; n; ++i) C1[i] = ((u64)C1[i] * ga[i] + (u64)C2[i] * fa[i]) % mod; DIT(C1); for (i = M; i &lt; R; ++i) f[i] = (f[i] + C1[n - (i - L)] * iv) % mod; &#125; else &#123; memcpy(C1, f, 2 &lt;&lt; w), memset(C1 + M, 0, 2 &lt;&lt; w), memcpy(C2, g, 2 &lt;&lt; w), memset(C2 + M, 0, 2 &lt;&lt; w), DIF(C1), DIF(C2), memcpy(fn + (1 &lt;&lt; (w - 1)), C1, 2 &lt;&lt; w), memcpy(gn + (1 &lt;&lt; (w - 1)), C2, 2 &lt;&lt; w); for (i = 0; i &lt; n; ++i) C1[i] = (u64)C1[i] * C2[i] % mod; DIT(C1); for (i = M; i &lt; R; ++i) f[i] = (f[i] + C1[n - i] * iv) % mod; &#125; solve(M, w - 1); &#125;&#125;namespace poly_evaluation &#123; using namespace poly_base; int cnt = 0, lc[N], rc[N]; vec Prd_, E1, E2, E3; vector g[N], tmp_; int solve(int L, int R) &#123; if (L + 1 == R) return L; int M = (L + R) / 2, id = cnt++, lp = solve(L, M), rp = solve(M, R); return poly::mul(g[lp], g[rp], g[id]), lc[id] = lp, rc[id] = rp, id; &#125; void recursion(int id, int L, int R, const vector &amp;poly) &#123; if (L + 1 == R) return tmp_.EB(poly.back()); int i, n = poly.size() - 1, M = (L + R) / 2, lp = lc[id], rp = rc[id], dl = min(n, g[lp].size() - 1), dr = min(n, g[rp].size() - 1); if (L + 2 == R) return tmp_.EB((poly[n] + (u64)poly[n - 1] * g[rp].back()) % mod), tmp_.EB((poly[n] + (u64)poly[n - 1] * g[lp].back()) % mod); vector ly, ry; ly.reserve(dl + 1), ry.reserve(dr + 1); NTT_init(lg2(dl + dr) + 1); memcpy(E1, poly.data(), (n + 1) &lt;&lt; 2), DIF(E1, E2), memset(E1, 0, (n + 1) &lt;&lt; 2); memcpy(E1, g[rp].data(), (dr + 1) &lt;&lt; 2), DIF(E1, E3), memset(E1, 0, (dr + 1) &lt;&lt; 2); for (i = 0; i &lt; poly::n; ++i) E3[i] = (u64)E3[i] * E2[i] % mod; DIT(E3), std::reverse(E3 + 1, E3 + poly::n); for (i = n - dl; i &lt;= n; ++i) ly.EB(E3[i] * iv % mod); memcpy(E1, g[lp].data(), (dl + 1) &lt;&lt; 2), DIF(E1, E3), memset(E1, 0, (dl + 1) &lt;&lt; 2); for (i = 0; i &lt; poly::n; ++i) E3[i] = (u64)E3[i] * E2[i] % mod; DIT(E3), std::reverse(E3 + 1, E3 + poly::n); for (i = n - dr; i &lt;= n; ++i) ry.EB(E3[i] * iv % mod); recursion(lp, L, M, ly), recursion(rp, M, R, ry); &#125; vector emain(int n, pvec f, const vector &amp;pts) &#123; int i, id, m = pts.size(), q; if (!m) return vector(); if (!n) return vector(m, *f); for (i = 0; i &lt; m; ++i) g[i].clear(), g[i].EB(1), g[i].EB(neg(q = pts[i])); id = solve(0, cnt = m), memcpy(Prd_, g[id].data(), (m + 1) &lt;&lt; 2); poly::inv(n + 1, Prd_, E2), memset(Prd_, 0, (m + 1) &lt;&lt; 2); if (n &gt; 0) memset(E2 + (n + 1), 0, (poly::n - n - 1) &lt;&lt; 2); std::reverse_copy(f, f + (n + 1), E1), poly::mul(2 * n, E1, E2, E3), memset(E1, 0, (n + 1) &lt;&lt; 2), memset(E2, 0, (n + 1) &lt;&lt; 2); return tmp_.clear(), tmp_.reserve(m), recursion(id, 0, m, vector(E3 + max(n - m + 1, 0), E3 + (n + 1))), tmp_; &#125;&#125;namespace poly_interpolation &#123; using namespace poly_evaluation; vec I1, I2, I3, I4, I5; pvec iresult; void irecursion(int id, int L, int R) &#123; if (L + 1 == R) return; int i, M = (L + R) / 2, lp = lc[id], rp = rc[id]; irecursion(lp, L, M), irecursion(rp, M, R); NTT_init(lg2(R - L - 1) + 1); memcpy(I1, iresult + L, (M - L) &lt;&lt; 2), memset(I1 + (M - L), 0, (poly::n - (M - L)) &lt;&lt; 2); memcpy(I2, iresult + M, (R - M) &lt;&lt; 2), memset(I2 + (R - M), 0, (poly::n - (R - M)) &lt;&lt; 2); memcpy(I3, g[lp].data(), (M - L + 1) &lt;&lt; 2), memset(I3 + (M - L + 1), 0, (poly::n - (M - L + 1)) &lt;&lt; 2); memcpy(I4, g[rp].data(), (R - M + 1) &lt;&lt; 2), memset(I4 + (R - M + 1), 0, (poly::n - (R - M + 1)) &lt;&lt; 2); DIF(I1), DIF(I2), DIF(I3), DIF(I4); for (i = 0; i &lt; n; ++i) I1[i] = ((u64)I1[i] * I4[i] + (u64)I2[i] * I3[i]) % mod; DIT(I1), std::reverse(I1 + 1, I1 + n); for (i = 0; i &lt; R - L; ++i) iresult[L + i] = I1[i] * iv % mod; &#125; void imain(int n, pr *pts, pvec ret) &#123; int i, id, q; assert(n &gt; 0); for (i = 0; i &lt; n; ++i) g[i].clear(), g[i].EB(1), g[i].EB(neg(q = pts[i].first)); id = solve(0, cnt = n), memcpy(Prd_, g[id].data(), (n + 1) &lt;&lt; 2); poly::inv(n, Prd_, E2), memset(Prd_, 0, n &lt;&lt; 2); if (n &gt; 1) memset(E2 + n, 0, (poly::n - n) &lt;&lt; 2); for (i = 0; i &lt; n; ++i) E1[i] = u64(n - i) * g[id][i] % mod; poly::mul(2 * (n - 1), E1, E2, E3), memset(E1, 0, n &lt;&lt; 2), memset(E2, 0, n &lt;&lt; 2); tmp_.clear(), tmp_.reserve(n), recursion(id, 0, n, vector(E3, E3 + n)); for (i = 0; i &lt; n; ++i) ret[i] = PowerMod(tmp_[i], mod - 2, pts[i].second); iresult = ret, irecursion(id, 0, n), std::reverse(ret, ret + n); &#125;&#125;namespace linear_recur &#123; using namespace poly_base; int ld; vec f, g, L1, L2, L3; void __builtin_divmod(int d) &#123; int i; NTT_init(ld); std::reverse_copy(f + d, f + 2 * d, L3); memset(L3 + d, 0, (n - d) &lt;&lt; 2); DNTT(L3); for (i = 0; i &lt; n; ++i) L3[i] = (u64)L3[i] * L2[i] % mod; IDNTT(L3); std::reverse(L3, L3 + d), memset(L3 + d, 0, (n - d) &lt;&lt; 2); DNTT(L3); for (i = 0; i &lt; n; ++i) L3[i] = (u64)L3[i] * L1[i] % mod; IDNTT(L3); for (i = 0; i &lt; d; ++i) reduce(f[i] -= L3[i]); memset(f + d, 0, d &lt;&lt; 2); &#125; void solve(int Q, int d) &#123; int i, df = 1, z = lg2(Q); bool alive = false; assert(d &gt; 0), ld = lg2(2 * d - 1) + 1; if (d == 1) alive = true, *f = 1; NTT_init(ld), std::reverse_copy(g + 1, g + (d + 1), L1), memset(L1 + d, 0, (n - d) &lt;&lt; 2), poly::inv(d, L1, L2); NTT_init(ld), memset(L2 + d, 0, (n - d) &lt;&lt; 2), memcpy(L1, g, d &lt;&lt; 2), memset(L1 + d, 0, (n - d) &lt;&lt; 2), DIF(L1), DIF(L2); for (; --z &gt;= 0; ) &#123; df = df &lt;&lt; 1 | (Q &gt;&gt; z &amp; 1); if (df &lt; d) continue; if (!alive) alive = true, f[df &gt;&gt; 1] = 1; NTT_init(ld), DNTT(f); for (i = 0; i &lt; n; ++i) f[i] = (u64)f[i] * f[i] % mod; IDNTT(f); if (df &amp; 1) std::copy_backward(f, f + (2 * d - 1), f + 2 * d), *f = 0; __builtin_divmod(d); &#125; &#125;&#125;namespace linear_recur_single &#123; using namespace poly; int ld; vec f, g, L1, L2, L3, L4; int get(int Q, int d) &#123; if (Q &lt; d) return f[Q]; int i, j, ret = 0, halves = 0; assert(d &gt; 0), ld = lg2(2 * d - 1) + 1, mul(2 * d - 1, f, g, L1), memset(L1 + d, 0, (n - d) &lt;&lt; 2), memcpy(L2, g, (d + 1) &lt;&lt; 2), memset(L2 + (d + 1), 0, (n - d - 1) &lt;&lt; 2); for (; Q &gt;= d; Q &gt;&gt;= 1) &#123; NTT_init(ld), DIF(L1, L4), DIF(L2, L3), NTT_init(ld - 1), ++halves; if (Q &amp; 1) &#123; for (j = i = 0; i &lt; n; ++i, j += 2) L4[i] = ((u64)L4[j] * L3[j + 1] + u64(mod - L3[j]) * L4[j + 1]) % mod; for (i = 0; i &lt; n; ++i) L4[i] = (u64)L4[i] * w2[i] % mod; IDNTT(L4), L4[n] = *L4, memcpy(L1, L4 + 1, d &lt;&lt; 2); &#125; else &#123; for (j = i = 0; i &lt; n; ++i, j += 2) L4[i] = ((u64)L4[j] * L3[j + 1] + (u64)L3[j] * L4[j + 1]) % mod; IDNTT(L4, L1); &#125; for (j = i = 0; i &lt; n; ++i, j += 2) L3[i] = (u64)L3[j] * L3[j + 1] % mod; IDNTT(L3, L2); if (*L2 != 1) L2[d] = (*L2 ? *L2 : mod) - 1, *L2 = 1; &#125; poly::inv(Q + 1, L2, L3); for (i = 0; i &lt;= Q; ++i) ret = (ret + (u64)L1[i] * L3[Q - i]) % mod; return PowerMod(iv2, halves, ret); &#125;&#125;namespace miscellaneous &#123; using namespace poly_base; vec M1, M2, M3, M4; vec Ma[200]; // calculate b(x) = a(x + c), poly_base::init need &#x27;false&#x27; void translate(int deg, pvec a, int c, pvec b) &#123; if (!deg) &#123;*b = *a; return;&#125; int i; u64 pc = 1; NTT_init(lg2(deg) + 2); for (i = 0; i &lt;= deg; ++i) M1[i] = (u64)a[i] * fact[i] % mod; memset(M1 + i, 0, (n - i) &lt;&lt; 2); for (i = deg; i &gt;= 0; --i, pc = pc * c % mod) M2[i] = finv[deg - i] * pc % mod; DIF(M1), DIF(M2); for (i = 0; i &lt; n; ++i) M1[i] = (u64)M1[i] * M2[i] % mod; DIT(M1); for (i = 0; i &lt;= deg; ++i) b[i] = M1[n - deg - i] * iv % mod * finv[i] % mod; &#125; // compute a(1), a(z), a(z^2), ..., a(z^(len-1)) to b void czt(int deg, int len, int z, pvec a, pvec b) &#123; int i; u64 iz = PowerMod(z, mod - 2); if (!len) return; if (!deg || !z) return std::fill(b, b + len, *a); NTT_init(lg2(deg + len - 1) + 1); M1[1] = *M1 = M3[1] = *M3 = 1; for (i = 2; i &lt; deg + len; ++i) M1[i] = M1[i - 1] * (u64)z % mod, M3[i] = M3[i - 1] * iz % mod; for (i = 2; i &lt; deg + len; ++i) M1[i] = (u64)M1[i] * M1[i - 1] % mod, M3[i] = (u64)M3[i] * M3[i - 1] % mod; memset(M1 + i, 0, (n - i) &lt;&lt; 2); for (i = 0; i &lt;= deg; ++i) M2[deg - i] = (u64)M3[i] * a[i] % mod; memset(M2 + i, 0, (n - i) &lt;&lt; 2), DIF(M1), DIF(M2); for (i = 0; i &lt; n; ++i) M1[i] = (u64)M1[i] * M2[i] % mod; DIT(M1); for (i = 0; i &lt; len; ++i) b[i] = M1[n - deg - i] * iv % mod * M3[i] % mod; &#125; inline int __builtin_inner(int len, pvec a, pvec b) &#123; int i = 0; u64 ans = 0; #define term(k) (u64)a[i + k] * b[i + k] for (; i + 15 &lt; len; i += 16) &#123; ans = (ans + term(0) + term(1) + term(2) + term(3) + term(4) + term(5) + term(6) + term(7) + term(8) + term(9) + term(10) + term(11) + term(12) + term(13) + term(14) + term(15) ) % mod; &#125; #undef term for (; i &lt; len; ++i) ans += (u64)a[i] * b[i]; return ans % mod; &#125; // compositional inverse void cinv(int deg, pvec a, pvec b) &#123; assert(!*a), *b = 0; if (--deg &lt;= 0) return; int i, j, k, d, B, *c; NTT_init(lg2(2 * deg - 1)), memcpy(M1, a + 1, deg &lt;&lt; 2), memset(M1 + deg, 0, (n - deg) &lt;&lt; 2), poly::inv(deg, M1, M2), NTT_init(lg2(2 * deg - 1) + 1), memset(M2 + deg, 0, (n - deg) &lt;&lt; 2), DIF(M2, M1), B = sqrt(deg), memset(*Ma, 0, n &lt;&lt; 2), **Ma = 1; for (j = 1; j &lt;= B; ++j) &#123; DIF(Ma[j - 1], M3), c = Ma[j]; for (i = 0; i &lt; n; ++i) M3[i] = (u64)M3[i] * M1[i] % mod; DIT(M3), *c = *M3 * iv % mod; for (i = 1; i &lt; deg; ++i) c[i] = M3[n - i] * iv % mod; memset(c + i, 0, (n - i) &lt;&lt; 2); &#125; DIF(Ma[B], M1), memset(M3, 0, n &lt;&lt; 2), *M3 = M4[deg - 1] = 1; for (d = 0; ; ) &#123; for (k = 0; k &lt; B &amp;&amp; d &lt; deg; ++k, ++d) b[d + 1] = (u64)__builtin_inner(d + 1, Ma[k + 1], M4 + (deg - d - 1)) * inv[d + 1] % mod; if (d &gt;= deg) break; DIF(M3); for (i = 0; i &lt; n; ++i) M3[i] = (u64)M3[i] * M1[i] % mod; DIT(M3), *M3 = *M3 * iv % mod; for (i = 1; i &lt; deg; ++i) M3[i] = M3[n - i] * iv % mod; memset(M3 + i, 0, (n - i) &lt;&lt; 2), std::reverse_copy(M3, M3 + deg, M4); &#125; &#125;&#125; 生成函数普通生成函数单下标序列普通型生成函数$$A(x)&#x3D; \\sum_{n&#x3D;0}^{\\infty} a_{n}x^{n}$$ $$A(x_{1},x_{2})&#x3D; \\sum_{n&#x3D;0}^{\\infty} a_{n,m}x_{1}^{n}x_{2}^{m}$$ $$\\frac{1}{1-x}&#x3D; \\sum_{i&#x3D;0}^{\\infty} x^{i}$$ $$ln(1+x)&#x3D; \\sum_{i&#x3D;0}^{\\infty}(-1)^{i} \\frac{x^{i+1}}{i+1}$$ $$(1+x)^{n}&#x3D; \\sum_{i&#x3D;0}^{\\infty} a^{i} \\frac{x^{i}}{i!}$$ $$sin(x)&#x3D; \\sum_{i&#x3D;0}^{\\infty}(-1)^{i} \\frac{x^{2i+1}}{(2i+1)!}$$ $$cos(x)&#x3D; \\sum_{i&#x3D;0}^{\\infty} (-1)^{i} \\frac{x^{2i}}{(2i)!}$$ 指数型生成函数一般形式$$G(x)&#x3D; \\sum_{i&#x3D;0}^{\\infty} a_{i} \\frac{x^{i}}{i!}$$ $$F(x)&#x3D; \\sum_{i&#x3D;0}^{\\infty} b_{i} \\frac{x^{i}}{i!}$$ $$F(x) \\times G(x) &#x3D; (\\sum_{i&#x3D;0}^{\\infty}a_{i} \\frac{x^{i}}{i!})(\\sum_{i&#x3D;0}^{\\infty} b_{i} \\frac{x^{i}}{i!}) &#x3D; \\sum_{n&#x3D;0}^{\\infty} (\\sum_{i&#x3D;0}^{\\infty}\\frac{a_i x^{i}}{i!} \\times \\frac{b_{n-i}x^{n-i}}{(n-i)!})x^{n} &#x3D; \\sum_{n&#x3D;0} ^{\\infty} (\\sum_{i&#x3D;0}^{\\infty}\\binom{n}{i}a_{i} b_{n-i}) \\frac{x^{n}}{n!} F(x) \\cdot G(x)$$ 指数型生成函数常用公式$$e^x &#x3D; \\sum_{i&#x3D;0}^{\\infty} \\frac{x^i}{i!} &#x3D; 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots + \\frac{x^n}{n!} + \\cdots$$ $$\\frac{e^x + e^{-x}}{2} &#x3D; \\sum_{i&#x3D;0}^{\\infty} \\frac{x^{2i}}{(2i)!}$$ $$\\frac{e^x - e^{-x}}{2} &#x3D; \\sum_{i&#x3D;0}^{\\infty} \\frac{x^{2i+1}}{(2i+1)!}$$ 二项式定理$$(x + 1)^n &#x3D; \\sum_{i&#x3D;0}^{n} \\binom{n}{i} x^i$$ $$(1 + x)^{-n} &#x3D; \\frac{1}{(1 + x)^{n}} &#x3D; \\sum_{i&#x3D;0}^{\\infty} \\binom{i-n}{i} x^i &#x3D; \\sum_{i&#x3D;0}^{\\infty} (-1)^i \\binom{n+i-1}{i} x^i$$ $$(1 - x)^n &#x3D; \\sum_{i&#x3D;0}^{\\infty} (-1)^i \\binom{n}{i} x^i (1 - x)^n &#x3D; \\sum_{i&#x3D;0}^{\\infty} (-1)^i \\binom{n}{i} x^i$$ $$(x + y)^n &#x3D; \\sum_{i&#x3D;0}^{n} \\binom{n}{i} a^i b^{n-i}$$ $$\\frac{1}{(1 - x)^n} &#x3D; \\sum_{i&#x3D;0}^{\\infty} \\binom{n+i-1}{i} x^i$$ 博弈论巴什博弈一堆石子n个，每次最少取一个，最多取m个，先手必胜点为n%(m+1)!&#x3D;0 NIM博弈N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜，其先手必胜点为所有对取异或不为0 威佐夫博弈有两堆各若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。则是奇异局势先手输， 奇异局势局势的第一个值是未在前面出现过的最小的自然数。 继续分析我们会发现，每种奇异局势的第一个值(这里假设第一堆数目小于第二堆的数目)总是等于当前局势的差值乘上1.618，而1.618 &#x3D; (sqrt(5.0) + 1) &#x2F; 2 sg函数1234567891011121314151617const int N = 1e4 + 5;void getsg()&#123; memset(sg, 0, sizeof(sg)); for (int i = 1; i &lt;= N; i++) &#123; memset(s, 0, sizeof(s)); for (int j = 2; j &lt;= 24 &amp;&amp; dp[j] &lt;= i; j++) &#123;这里的df[i]为每次可以取走的个数 s[sg[i - dp[j]]] = 1; &#125; for (int j = 0; j &lt;= N; j++) &#123; if (!s[j]) &#123; sg[i] = j; break; &#125; &#125; &#125;&#125; 组合数学组合数计算数据a，b均小于200012345678910111213141516171819const int MOD = 1e9 + 7;const int N = 2e3 + 5;int c[N][N];void init()&#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD; &#125; &#125;&#125;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; c[a][b] &lt;&lt; endl; return 0;&#125; 数据在1e5以内1234567891011121314151617181920212223int f[N], inf[N];int ksm(int a, int b, int m)&#123; int ans = 1; while (b &gt;= 1) &#123; if (b &amp; 1) ans = (ans * a) % m; b = b &gt;&gt; 1; a = (a * a) % m; &#125; return ans;&#125;void init()&#123; f[0] = inf[0] = 1; for (int i = 1; i &lt; N; i++) &#123; f[i] = f[i - 1] * i % MOD; inf[i] = inf[i - 1] * ksm(i, MOD - 2, MOD) % MOD; &#125;&#125;int C(int a,int b)&#123; return f[a] * inf[b] % MOD * inf[a - b] % MOD;&#125; 数据达到1e18123456789101112131415161718192021222324252627282930313233343536373839typedef long long LL;LL ksm(LL a, LL b, LL c)&#123; LL ans = 1;//最后答案在ans while (b &gt; 0) &#123; if (b &amp; 1)//b是奇数的话会出现一个a &#123; ans = ans * a % c; &#125; b &gt;&gt;= 1; a = (a * a) % c;//b变一半所以a就要平方了 &#125; return ans;&#125;LL C(LL n, LL m, LL MOD)&#123; if (m &gt; n) return 0; m = min(m, n - m); LL a = 1, b = 1; while (m) &#123; a = a * n % MOD; b = b * m % MOD; n--; m--; &#125; return a * ksm(b, MOD - 2, MOD) % MOD;&#125;LL lucas(LL n, LL m, LL p)&#123; if (m == 0) return 1; return C(n % p, m % p, p) * lucas(n / p, m / p, p) % p;&#125;int main()&#123; LL a, b; cin &gt;&gt; a &gt;&gt; b &gt;&gt; m; cout &lt;&lt; lucas(a, b) &lt;&lt; endl; return 0;&#125; 扩展卢卡斯定理用于p为非质数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110int ksm(int a, int b, int c)&#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % c; b &gt;&gt;= 1; a = a * a % c; &#125; return ans;&#125;int cal(int n, int p, int pa)&#123; if (!n) &#123; return 1; &#125; int ans = 1; for (int i = 1; i &lt;= pa; i++) &#123; if (i % p) &#123; ans = ans * i % pa; &#125; &#125; ans = ksm(ans, n / pa, pa); for (int i = 1; i &lt;= n % pa; i++) &#123; if (i % p) &#123; ans = ans * i % pa; &#125; &#125; return ans * cal(n / p, p, pa) % pa;&#125;int cnt_p(int n, int m, int p)&#123; int cnt = 0; for (int i = p; i &lt;= n; i *= p) &#123; cnt += n / i; &#125; for (int i = p; i &lt;= m; i *= p) &#123; cnt -= m / i; &#125; for (int i = p; i &lt;= n - m; i *= p) &#123; cnt -= (n - m) / i; &#125; return cnt;&#125;int x, y;void exgcd(int a, int b)&#123; if (!b) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b); int tmp = x; x = y; y = tmp - a / b * y;&#125;int inv(int a, int p)&#123; exgcd(a, p); x = (x % p + p) % p; return x;&#125;int C(int n, int m, int p, int pa)&#123; int a = cal(n, p, pa), b = cal(m, p, pa), c = cal(n - m, p, pa), cnt = cnt_p(n, m, p); return a * inv(b, pa) % pa * inv(c, pa) % pa * ksm(p, cnt, pa) % pa;&#125;int a[10], b[10];int CRT(int n)&#123; int m = 1; for (int i = 1; i &lt;= n; i++) &#123; m *= a[i]; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int mi = m / a[i]; int Mi = inv(mi, a[i]); ans = (ans + b[i] * mi % m * Mi % m) % m; &#125; return ans;&#125;int exLucas(int n, int m, int p)&#123; int k = 0; for (int i = 2; i * i &lt;= p; i++) &#123; if (p % i == 0) &#123; a[++k] = 1; while (p % i == 0) &#123; a[k] *= i; p /= i; &#125; b[k] = C(n, m, i, a[k]); &#125; &#125; if (p &gt; 1) &#123; a[++k] = p; b[k] = C(n, m, p, p); &#125; return CRT(k);&#125; 高精度组合数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int primes[N],co;bool st[N];void p(int n) //筛选出所有互质的数&#123; co=0; for(int i=2;i&lt;=n;i++) &#123; if(!st[i]) primes[co++]=i; for(int j=0;primes[j]&lt;=n/i;j++) &#123; st[primes[j]*i]=1; if(i % primes[j]==0) break; &#125; &#125;&#125;int calc(int n,int pr) //计算每一个数的阶乘具有多少个primes[i]&#123; int s=0; while(n&gt;0) &#123; s+=n/pr; n/=pr; &#125; return s;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a,int b) //高精度乘法&#123; vector&lt;int&gt; c; int t=0; for(int i=0;i&lt;a.size();i++) &#123; t+=a[i]*b; c.push_back(t%10); t/=10; &#125; while(t) &#123; c.push_back(t%10); t/=10; &#125; return c;&#125;int main()&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); p(a); int num[N]; for(int i=0;i&lt;co;i++) &#123; int pr = primes[i]; num[i] = calc(a,pr) - calc(b,pr) - calc(a-b,pr); &#125; vector&lt;int&gt; ans; ans.push_back(1); for(int i=0;i&lt;co;i++) &#123; while(num[i]--) ans = mul(ans,primes[i]); &#125; for(int i=ans.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,ans[i]); return 0;&#125; 多重集的排列组合 排列数 排列数 r &#x3D; n 则$\\ N &#x3D; \\frac{n!}{n_{1}!n_{2}!n_{3}!****n_{k}!}$ 排列数（r &lt;&#x3D; 每一个$\\ n_{i} $） 则 $ N&#x3D;k^r$ 组合数 （r &lt;&#x3D; 每一个$\\ n_{i} $）$\\ N &#x3D; C(k+r-1,r) $ 群论两种模型旋转同构仅适用于二维 123456789101112131415161718192021222324252627282930313233343536373839404142int n, M, ans;int a[N], m[N];intksc(int a, int b, int c)&#123; int ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % c; b &gt;&gt;= 1; a = (a + a) % c; &#125; return ans;&#125;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int excrt()&#123; M = m[1], ans = a[1]; for (int i = 2; i &lt;= n; i++) &#123; int p = ((a[i] - ans) % m[i] + m[i]) % m[i]; int x = 0, y = 0; int d = exgcd(M, m[i], x, y); if (p % d) return -1;//无解 x = ksc(x, p / d, m[i] / d); ans += x * M; M *= m[i] / d; ans = (ans % M + M) % M; &#125; return (ans % M + M) % M;&#125; 循环个数为gcd(n,k)，其中n为项链长度，旋转需要移动的k步，根据Polya定理有：$$ans&#x3D;\\frac{1}{n}\\sum_{i&#x3D;0}^{n-1} k^{gcd(i,n)}$$ 翻转同构翻转置换群大小为n（偶数时两种情况） eg：若一个项链可以通过另一个项链翻转得到，那么认为这两个项链为同一种项链 分奇偶讨论： 奇数 一定要有一个点在对称轴上，所以一共n条对称轴，共 $$ \\frac{n+1}{2} $$ 个循环 偶数 按边对称（即没有点在对称轴上） 共有$$ \\frac{n}{2} $$ 条对称轴， 形成$$ \\frac{n}{2} $$个循环 按点对称（即两个点在对称轴上） 共有$$ \\frac{n}{2} $$条对称轴，形成$$ \\frac{n + 2}{2} $$个循环 对称同构即为旋转同构+翻转同构，Polya定理代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//一定要手写求幂，pow函数在3^34时出错#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef long double LD;#define int LL#define double LD#define endl &quot;\\n&quot;typedef pair&lt;int, int&gt; PII;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;const double PI = acosl(-1.0);const double eps = 1e-8;int gcd(int a, int b)&#123; if (!b) return a; return gcd(b, a % b);&#125;int ksm(int a, int b)&#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; &#125; return ans;&#125;void solve()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n == 0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans += ksm(m, gcd(n, i)); &#125; if (n &amp; 1) &#123; ans += ksm(m, (n + 1) / 2) * n; &#125; else &#123; ans += ksm(m, n / 2) * n / 2; ans += ksm(m, (n + 2) / 2) * n / 2; &#125; ans /= (2 * n); cout &lt;&lt; ans &lt;&lt; endl;&#125;signed main()&#123; ios::sync_with_stdio(false), cin.tie(0); int _;// cin&gt;&gt;_; _ = 1; while (_--) &#123; solve(); &#125; return 0;&#125; 置换群快速幂结论一：长度为l的循环T，若l是k的倍数，那么$$ T^{k} $$为k个循环的乘积，且这k个循环分别是原循环T中下标$$ mod k&#x3D;0,1,2,…,$$（即$$ mod k$$的结果分组，每组为一个循环） 结论二：长度为l的循环T，若$$ gcd(l,k)&#x3D;1$$ ,那么 $$ T^{k} $$为一个循环 结论三：长度为l的循环T，$$ T^{k} $$是$$ gcd(l,k)$$个循环的乘积，每个循环为原循环T中下标 $$ mod k&#x3D;0,1,2,…,$$(按结果分组，每组一个循环，仅仅是由这些元素组成，并不是说还是这个顺序) 定理：设 $$ a&#x3D;T,a^{‘}&#x3D;T^{k},且gcd(l,k)&#x3D;1,则 a^{‘}[i]&#x3D;a[(k+1)i % l]$$ (下标范围0 ≤ i ≤ l-1) ，我认为应该是 $$ a^{‘}[i]&#x3D;a[ki % l] $$ 计算几何自适应辛普森积分123456789101112131415161718192021double f(double x)//原函数&#123; return ;//这里写原函数f(x)表达式&#125;double simpson(double l, double r) //Simpson公式&#123; double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;&#125;double asr(double l, double r, double eps, double tmp)&#123; double mid = (l + r) / 2; double ll = simpson(l, mid), rr = simpson(mid, r); if (fabs(ll + rr - tmp) &lt;= 15 * eps) return ll + rr + (ll + rr - tmp) / 15.0; //确认精度 return asr(l, mid, eps / 2, ll) + asr(mid, r, eps / 2, rr); //精度不够则递归调用&#125; /* asr(l, r, eps, simpson(l, r))*/ 基础函数及宏定义变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130const int N = 5007, M = 50007, INF = 0x3f3f3f3f;const double DINF = 1e18, eps = 1e-8;const double PI = acos(-1);struct Point &#123;//二维点 double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;//构造函数&#125;;typedef Point Vector;//向量 + 向量 = 向量，点 + 向量 = 向量Vector operator+(Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;//点 - 点 = 向量(向量BC = C - B)Vector operator-(Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;//向量 * 数 = 向量Vector operator*(Vector A, double p) &#123; return Vector(A.x * p, A.y * p); &#125;//向量 / 数= 向量Vector operator/(Vector A, double p) &#123; return Vector(A.x / p, A.y / p); &#125;//点/向量的比较函数bool operator&lt;(const Point &amp;a, const Point &amp;b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); &#125;struct Line &#123;//直线定义 Vector v; Point p; Line() &#123;&#125; Line(Vector v, Point p) : v(v), p(p) &#123;&#125; Point get_point_in_line(double t) &#123;//返回直线上一点P = p + v * t return p + v * t; &#125;&#125;;//单位弧度raddouble Polar_angle(Vector A) &#123; return atan2(A.y, A.x); &#125;//角度转弧度double torad(double deg) &#123; return deg / 180 * PI; &#125;//判断相等int sgn(double x)&#123;//也是dcmp if (fabs(x) &lt; eps) return 0; if (x &lt; 0) return -1; return 1;&#125;//重载等于运算符bool operator==(const Point &amp;a, const Point &amp;b) &#123; return !sgn(a.x - b.x) &amp;&amp; !sgn(a.y - b.y); &#125;//点积(满足交换律)double Dot(Vector A, Vector B) &#123; return A.x * B.x + A.y * B.y; &#125;//向量的叉积(不满足交换律)double Cross(Vector A, Vector B) &#123; return A.x * B.y - B.x * A.y; &#125;//计算两点距离距离double dis(Vector a, Vector b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) * 1.0 + (a.y - b.y) * (a.y - b.y));&#125;//极角排序//1.atan2排序，atan2(y,x)函数返回点(x,y)与原点连线与x轴正方向之间的夹角，[-pi,pi]bool cmp1(Point A, Point B)&#123; if (sgn(atan2(A.y, A.x) - atan2(B.y, B.x)) != 0) return atan2(A.y, A.x) &lt; atan2(B.y, B.x); return A.x &lt; B.x;&#125;//2.叉积排序（需要选定基准点P）Point Pole;bool Compare(Point A, Point B)&#123; if (sgn(Cross(A - Pole, B - Pole)) == 0) return A.x &lt; B.x; return Cross(A - Pole, B - Pole) &gt; 0;&#125;//3. 象限排序 原因：叉积排序是不能排序360度的。int Quadrant(Point A)//返回所在象限&#123; if (A.x &gt; 0 &amp;&amp; A.y &gt;= 0)return 1; if (A.x &lt;= 0 &amp;&amp; A.y &gt; 0)return 2; if (A.x &lt; 0 &amp;&amp; A.y &lt;= 0)return 3; if (A.x &gt;= 0 &amp;&amp; A.y &lt; 0)return 4;&#125;bool cmp2(Point A, Point B) //以原点为极点，先按照象限排序&#123; if (Quadrant(A) == Quadrant(B)) return cmp1(A, B); else return Quadrant(A) &lt; Quadrant(B);&#125;//判断向量bc是不是向ab的逆时针方向（左边）bool ToLeftTest(Point a, Point b, Point c)&#123; return Cross(b - a, c - b) &gt; 0;&#125;//取模（模长，求长度）double Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125;//计算两向量夹角double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;// 三角形面积叉乘公式double Area(Point A, Point B, Point C) &#123; return Cross(B - A, C - A) / 2; &#125;//计算两向量构成的平行四边形有向面积double Area2(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;//计算向量逆时针旋转九十度之后的单位法线（法向量）Vector Normal(Vector A)&#123; double L = Length(A); return Vector(-A.y / L, A.x / L);&#125;inline Vector Format(const Vector &amp;A)&#123; double L = Length(A); return Vector(A.x / L, A.y / L);&#125;//计算向量逆时针旋转后的向量Vector Rotate(Vector A, double rad)&#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;//点绕着 p 点逆时针旋转 anglePoint rotate(Point p, double angle)&#123; Point v = (*this) - p;//这里this不能用，为当前点绕p点的当前点 double c = cos(angle), s = sin(angle); return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);&#125;/*Point rotate(Point q, Point p, double angle) &#123; Point v = q - p;//这里this不能用，为当前点绕p点的当前点 double c = cos(angle), s = sin(angle); return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);&#125;*///将点A绕点B顺时针旋转theta(弧度)inline Point turn_PP(Point a, Point b, double theta)&#123; double x = (a.x - b.x) * cos(theta) + (a.y - b.y) * sin(theta) + b.x; double y = -(a.x - b.x) * sin(theta) + (a.y - b.y) * cos(theta) + b.y; return Point(x, y);&#125; 复数部分12345678910111213141516171819202122typedef complex&lt;double&gt; Point;typedef Point Vector;//复数定义向量后，自动拥有构造函数、加减法和数量积const double eps = 1e-9;int sgn(double x)&#123; if(fabs(x) &lt; eps) return 0; if(x &lt; 0) return -1; return 1;&#125;double Length(Vector A)&#123; return abs(A);&#125;double Dot(Vector A, Vector B)&#123;//conj(a+bi)返回共轭复数a-bi return real(conj(A)*B);&#125;double Cross(Vector A, Vector B)&#123; return imag(conj(A)*B);&#125;Vector Rotate(Vector A, double rad)&#123; return A*exp(Point(0, rad));//exp(p)返回以e为底复数的指数&#125; 二维计算几何基础点与线判断点和直线关系relation1 在左侧-1 在右侧0 在直线上 &#x2F;&#x2F;直线上两点s和eA, B:直线上一点,C:待判断关系的点 12345678int relation(Point A, Point B, Point C)&#123; // 1 left -1 right 0 in int c = sgn(Cross((B - A), (C - A))); if(c &lt; 0) return 1; else if(c &gt; 0) return -1; return 0;&#125; 计算两直线交点 Get_line_intersection调用前要确保两直线p + tv 和 Q + tw之间有唯一交点，当且仅当Corss(v, w) !&#x3D; 0;（t是参数） 123456Point Get_line_intersection(Point P,Vector v,Point Q,Vector w)&#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125; 计算点到直线的距离 Distance_point_to_line12345double Distance_point_to_line(Point P, Point A, Point B)&#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2) / Length(v1));//如果不取绝对值，那么得到的是有向距离&#125; 计算点到线段的距离 Distance_point_to_segment垂线距离或者PA或者PB距离 12345678double Distance_point_to_segment(Point P, Point A, Point B)&#123; if(A == B) return Length(P - A);//（如果重合那么就是两个点之间的距离，直接转成向量求距离即可） Vector v1 = B - A, v2 = P - A, v3 = P - B; if(sgn(Dot(v1, v2)) &lt; 0) return Length(v2);//A点左边 if(sgn(Dot(v1, v3)) &gt; 0)return Length(v3);//B点右边 return fabs(Cross(v1, v2) / Length(v1));//垂线的距离&#125; 求点在直线上的投影点 Get_line_projection12345Point Get_line_projection(Point P, Point A, Point B)&#123; Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125; 计算点 P 到直线 AB 的垂足 FootPoint12345inline Point FootPoint(Point p, Point a, Point b)&#123; Vector x = p - a, y = p - b, z = b - a; double len1 = Dot(x, z) / Length(z), len2 = - 1.0 * Dot(y, z) / Length(z);//分别计算AP,BP在AB,BA上的投影 return a + z * (len1 / (len1 + len2));//点A加上向量AF&#125; 计算点到直线的对称点 Symmetry_PL1234inline Point Symmetry_PL(Point p, Point a, Point b)&#123; return p + (FootPoint(p, a, b) - p) * 2; //实际上就是求垂足之后延长一倍得到的向量，与原来的点加起来就行了&#125; 判断点是否在线段上 OnSegment123bool OnSegment(Point p, Point a1, Point a2)&#123; return sgn(Cross(a1-p, a2-p)) == 0 &amp;&amp; sgn(Dot(a1-p, a2-p)) &lt;= 0;&#125; 判断点是否在一条线段上(不含端点) on_segment1234bool on_segment(Point P, Point a1, Point a2)&#123; return sgn(Cross(a1-P, a2-P)) == 0 &amp;&amp; sgn(Dot(a1 - P, a2 - P)) &lt; 0;&#125; 判断两线段是否相交（不算在端点处相交）segment_proper_intersection123456bool segment_proper_intersection(Point a1, Point a2, Point b1, Point b2)&#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(c3) * sgn(c4) &lt; 0;&#125; 判断两线段是否相交（包含端点处相交） Segment_proper_intersection1234567891011121314bool Segment_proper_intersection(Point a1, Point a2, Point b1, Point b2)&#123; double c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1); double c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1); //if判断控制是否允许线段在端点处相交，根据需要添加 if(!sgn(c1) || !sgn(c2) || !sgn(c3) || !sgn(c4))&#123; bool f1 = OnSegment(b1, a1, a2); bool f2 = OnSegment(b2, a1, a2); bool f3 = OnSegment(a1, b1, b2); bool f4 = OnSegment(a2, b1, b2); bool f = (f1|f2|f3|f4); return f; &#125; return (sgn(c1)*sgn(c2) &lt; 0 &amp;&amp; sgn(c3)*sgn(c4) &lt; 0);&#125; 两向量的关系 parallel直线v和直线Line(s, e); 123bool parallel(Line v)&#123; return sgn((e−s)^(v.e−v.s)) == 0; &#125; 两直线关系 linecrossline0 平行1 重合2 相交 12345int linecrossline(Line v)&#123; if((*this).parallel(v)) return v.relation(s)==3; return 2; &#125; 多边形三角形四心 外心：三边中垂线交点，到三角形三个顶点距离相同（外接圆圆心） 内心：角平分线的交点，到三角形三边的距离相同（内切圆圆心） 垂心：三条垂线的交点 重心：三条中线的交点，到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点 重心$$\\left (\\frac{ x1+x2+x3}{3} ,\\frac{y1+y2+y3}{3}\\right )$$ 垂心 getcircle12345inline Circle getcircle(Point A,Point B,Point C)&#123; Point P1=(A+B)*0.5,P2=(A+C)*0.5; Point O=cross_LL(P1,P1+Normal(B-A),P2,P2+Normal(C-A)); return Circle(O,Len(A-O));&#125; 三角形面积并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;const int maxn = 110;#define x first#define y secondtypedef pair&lt;double, double&gt; PDD;const double eps = 1e-8;const double pi = acos(-1);const double inf = 1e12;PDD tr[maxn][3];PDD q[maxn];int n;int sign(double x)&#123; if(fabs(x) &lt; eps) return 0; if(x &lt; 0) return -1; return 1;&#125;int dcmp(double x, double y)&#123; if(fabs(x - y) &lt; eps) return 0; if(x &lt; y) return -1; return 1;&#125;PDD operator + (PDD a, PDD b)&#123; return &#123;a.x + b.x, a.y + b.y&#125;;&#125;PDD operator - (PDD a, PDD b)&#123; return &#123;a.x - b.x, a.y - b.y&#125;;&#125;PDD operator * (PDD a, double t)&#123; return &#123;a.x * t, a.y * t&#125;;&#125;PDD operator / (PDD a, double t)&#123; return &#123;a.x / t, a.y / t&#125;;&#125;double operator * (PDD a, PDD b)&#123; return a.x * b.y - a.y * b.x;&#125;double operator &amp; (PDD a, PDD b)&#123; return a.x * b.x + a.y * b.y;&#125;bool on_segment(PDD p, PDD a, PDD b)&#123; return sign((p - a) &amp; (p - b)) &lt;= 0;&#125;PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w)&#123; if(!sign(v * w)) return &#123;inf, inf&#125;; auto u = p - q; double t = w * u / (v * w); auto o = p + v * t; if(!on_segment(o, p, p + v) || !on_segment(o, q, q + w)) return &#123;inf, inf&#125;; return o;&#125;double line_range(double a, int side) // 求区间上线段并集长度，side用于区分左右&#123; int cnt = 0; for(int i = 0; i &lt; n; i ++)&#123; auto t = tr[i]; if(dcmp(t[0].x, a) &gt; 0 || dcmp(t[2].x, a) &lt; 0) continue; if(!dcmp(t[0].x, a) &amp;&amp; !dcmp(t[1].x, a))&#123; // 特判一下左边和直线重合的情况 if(side)&#123; q[cnt ++] = &#123;t[0].y ,t[1].y&#125;; &#125; &#125; else if(!dcmp(t[2].x, a) &amp;&amp; !dcmp(t[1].x, a))&#123; // 特判一下右边和直线重合的情况 if(!side)&#123; q[cnt ++] = &#123;t[2].y, t[1].y&#125;; &#125; &#125;else&#123; double d[3]; int u = 0; for(int j = 0; j &lt; 3; j ++)&#123; auto o = get_line_intersection(t[j], t[(j + 1) % 3] - t[j], &#123;a, -inf&#125;, &#123;0, inf * 2&#125;); if(dcmp(o.x, inf)) d[u ++] = o.y; &#125; if(u)&#123; sort(d, d + u); q[cnt ++] = &#123;d[0], d[u - 1]&#125;; &#125; &#125; &#125; if(!cnt) return 0; for(int i = 0; i &lt; cnt; i ++)&#123; // 确保小的在下方，大的在上方 if(q[i].x &gt; q[i].y) swap(q[i].x, q[i].y); &#125; sort(q, q + cnt); // 求一遍区间合并 double res = 0, st = q[0].x, ed = q[0].y; for(int i = 1; i &lt; cnt; i ++)&#123; if(q[i].x &lt;= ed) ed = max(ed, q[i].y); else &#123; res += ed - st; st = q[i].x, ed = q[i].y; &#125; &#125; res += ed - st; return res;&#125;double range_area(double a, double b)&#123; return (line_range(a, 1) + line_range(b, 0)) * (b - a) / 2;&#125;int main()&#123; cin &gt;&gt; n; vector&lt;double&gt; v; for(int i = 0; i &lt; n; i ++)&#123; for(int j = 0; j &lt; 3; j ++)&#123; cin &gt;&gt; tr[i][j].x &gt;&gt; tr[i][j].y; v.push_back(tr[i][j].x); &#125; sort(tr[i], tr[i] + 3); // 排序后，方便求交点 &#125; for(int i = 0; i &lt; n; i ++)&#123; // 求每两条边的交点 for(int j = 0; j &lt; n; j ++)&#123; for(int x = 0; x &lt; 3; x ++)&#123; for(int y = 0; y &lt; 3; y ++)&#123; auto o = get_line_intersection(tr[i][x], tr[i][(x + 1) % 3] - tr[i][x], tr[j][y], tr[j][(y + 1) % 3] - tr[j][y]); if(dcmp(o.x, inf)) v.push_back(o.x); // 如果存在交点 &#125; &#125; &#125; &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); double res = 0; for(int i = 0; i &lt; v.size() - 1; i ++)&#123; res += range_area(v[i], v[i + 1]); &#125; printf(&quot;%.2lf\\n&quot;, res); return 0;&#125; 凸多边形面积 convex_polygon_area叉积的几何意义就是三角形有向面积的二倍，所以这里要除以二 12345678double convex_polygon_area(Point* p, int n)&#123; double area = 0; for(int i = 1; i &lt;= n - 2; ++ i) area += Cross(p[i] - p[0], p[i + 1] - p[0]); return area / 2; //return fabs(area / 2);//不加的话求的是有向面积，逆时针为负，顺时针为正&#125; 非凸多边形面积 polyg_on_area我们叉积求得的三角形面积是有向的，在外面的面积可以正负抵消掉，因此非凸多边形也适用，可以从任意点出发划分可以取原点为起点，减少叉乘次数 1234567double polyg_on_area(Point* p, int n)&#123; double area = 0; for(int i = 1; i &lt;= n - 2; ++ i) area += Cross(p[i] - p[0], p[i + 1] - p[0]); return area / 2;&#125; 判断点在多边形内 is_point_in_polygon若点在多边形内返回1，在多边形外部返回0，在多边形上返回-1 123456789101112131415int is_point_in_polygon(Point p, vector&lt;Point&gt; poly)&#123;//待判断的点和该多边形的所有点的合集 int wn = 0; int n = poly.size(); for(int i = 0; i &lt; n; ++i)&#123; if(OnSegment(p, poly[i], poly[(i+1)%n])) return -1; int k = sgn(Cross(poly[(i+1)%n] - poly[i], p - poly[i])); int d1 = sgn(poly[i].y - p.y); int d2 = sgn(poly[(i+1)%n].y - p.y); if(k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if(k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if(wn != 0) return 1; return 0;&#125; 判断点在凸多边形内 ToLeftTest只需要判断点是否在所有边的左边（按逆时针顺序排列的顶点集）可以使用ToLeftTest ，O ( n ) 判断折线（向量）bc是不是向（向量）ab的逆时针方向（左边）转向(ToLeftTest) 123bool ToLeftTest(Point a, Point b, Point c)&#123; return Cross(b - a, c - b) &gt; 0;&#125; 圆定义 1234567891011121314151617181920struct Circle&#123; Point c; double r; Circle(Point c=Point(),double r=0):c(c),r(r)&#123;&#125; inline Point point(double a)//通过圆心角求坐标 &#123; return Point(c.x+cos(a)*r,c.y+sin(a)*r); &#125;&#125;;//读入圆inline Circle read_circle()&#123; Circle C; scanf(&quot;%lf%lf%lf&quot;,&amp;C.c.x,&amp;C.c.y,&amp;C.r); return C;&#125;//xmult函数只在圆中有应用并不常见double xmult(Point p1,Point p2,Point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125; 圆与直线交点 getLineCircleIntersection123456789101112131415161718int getLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) &#123; double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r; double delta = f * f - 4 * e * g;//判别式 if (sgn(delta) &lt; 0)//相离 return 0; if (sgn(delta) == 0) &#123;//相切 t1 = t2 = -f / (2 * e); sol.push_back(L.get_point_in_line(t1));//sol存放交点本身 return 1; &#125; //相交 t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.get_point_in_line(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.get_point_in_line(t2)); return 2;&#125; 求两圆交点 get_circle_circle_intersection两圆相交保存所有交点返回交点个数（至多两个） 12345678910111213141516171819int get_circle_circle_intersection(Circle c1, Circle c2, vector&lt;Point&gt;&amp; sol)&#123; double d = Length(c1.c - c2.c); if (sgn(d) == 0) &#123; if (sgn(c1.r - c2.r) == 0)return -1;//两圆重合 return 0; &#125; if (sgn(c1.r + c2.r - d) &lt; 0)return 0;//相离 if (sgn(fabs(c1.r - c2.r) - d) &gt; 0)return 0;//在另一个圆的内部 double a = Polar_angle(c2.c - c1.c);//向量c1c2的极角 double da = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d)); //c1c2到c1p1的角 Point p1 = c1.point(a - da), p2 = c1.point(a + da); sol.push_back(p1); if (p1 == p2)return 1; sol.push_back(p2); return 2;&#125; 点到圆的切线 get_tangents过点p到圆c的切线，v[i]是第i条切线， 返回切线的条数 123456789101112131415int get_tangents(Point p, Circle C, Vector* v) &#123; Vector u = C.c - p; double dist = Length(u); if (dist &lt; C.r)return 0;//点在内部，没有切线 else if (sgn(dist - C.r) == 0) &#123;//p在圆上，只有一条切线 v[0] = Rotate(u, PI / 2);//切线就是垂直嘛 return 1; &#125; else &#123;//否则是两条切线 double ang = asin(C.r / dist); v[0] = Rotate(u, -ang); v[1] = Rotate(u, +ang); return 2; &#125;&#125; 两圆的公切线 get_tangents根据两圆的圆心距从小到大排列，一共有6种情况。情况一：两圆完全重合。有无数条公切线。情况二：两圆内含，没有公共点。没有公切线。情况三：两圆内切。有1条外公切线。情况四：两圆相交。有2条外公切线。情况五：两圆外切。有3条公切线，其中一条内公切线，两条外公切线。情况六：两圆相离。有4条公切线，其中内公切线两条，外公切线两条。可以根据圆心距和半径的关系辨别出这6种情况，然后逐一求解。情况一和情况二没什么需要求的，情况三和情况五中的内公切线都对应于“过圆上一点求圆的切线”，只需连接圆心和切点，旋转90°后即可知道切线的方向向量。这样，问题的关键是求出情况四、五中的外公切线和情况六中的内公切线。 返回切线的条数，-1表示无穷条切线a[i]和b[i] 分别是第i条切线在圆A和圆B上的切点 1234567891011121314151617181920212223242526272829int get_tangents(Circle A, Circle B, Point* a, Point* b)&#123; int cnt = 0; if(A.r &lt; B.r)swap(A, B), swap(a, b); int d2 = (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); int rdiff = A.r - B.r; int rsum = A.r + B.r; if(d2 &lt; rdiff * rdiff)return 0;//内含 double base = atan2(B.y - A.y, B.x - A.x); if(d2 == 0 &amp;&amp; A.r == B.r)return -1;//无限多条切线 if(d2 == rdiff * rdiff)&#123;//内切，1条切线 a[cnt] = A.point(base); b[cnt] = B.point(base); cnt ++ ; return 1; &#125; //有外共切线 double ang = acos((A.r - B.r) / sqrt(d2)); a[cnt] = A.point(base + ang);b[cnt] = B.point(base + ang);cnt ++; a[cnt] = A.point(base - ang);b[cnt] = B.point(base - ang);cnt ++; if(d2 == rsum * rsum)&#123;//一条内公切线 a[cnt] = A.point(base);b[cnt] = B.point(PI + base); cnt ++ ; &#125; else if(d2 &gt; rsum * rsum)&#123;//两条内公切线 double ang = acos((A.r + B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt ++ ; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt ++ ; &#125; return cnt;&#125; 两圆相交面积 AreaOfOverlap通过计算两个圆相交所构成的两个扇形面积和减去其构成的筝形的面积 1234567891011121314151617double AreaOfOverlap(Point c1, double r1, Point c2, double r2)&#123; double d = Length(c1 - c2); if(r1 + r2 &lt; d + eps) return 0.0; if(d &lt; fabs(r1 - r2) + eps)&#123; double r = min(r1, r2); return PI*r*r; &#125; double x = (d*d + r1*r1 - r2*r2)/(2.0*d); double p = (r1 + r2 + d)/2.0; double t1 = acos(x/r1); double t2 = acos((d - x)/r2); double s1 = r1*r1*t1; double s2 = r2*r2*t2; double s3 = 2*sqrt(p*(p - r1)*(p - r2)*(p - d)); return s1 + s2 - s3;&#125; 判直线和圆是否相交,包括相切 intersect_line_circle需要计算点到直线距离函数 123int intersect_line_circle(Point c, double r, Point l1, Point l2) &#123; return Distance_point_to_line(c, l1, l2) &lt; r + eps;&#125; 判线段和圆相交,包括端点和相切 intersect_seg_circle123456789int intersect_seg_circle(Point c, double r, Point l1, Point l2) &#123; double t1 = dis(c, l1) - r, t2 = dis(c, l2) - r; Point t = c; if (t1 &lt; eps || t2 &lt; eps) return t1 &gt; -eps || t2 &gt; -eps; t.x += l1.y - l2.y; t.y += l2.x - l1.x; return xmult(l1, c, t) * xmult(l2, c, t) &lt; eps &amp;&amp; Distance_point_to_line(c, l1, l2) - r &lt; eps;&#125; 判圆和圆相交,包括相切 intersect_circle_circle123int intersect_circle_circle(Point c1, double r1, Point c2, double r2) &#123; return dis(c1, c2) &lt; r1 + r2 + eps &amp;&amp; dis(c1, c2) &gt; fabs(r1 - r2) - eps;&#125; 计算圆上到点p最近点,如p与圆心重合,返回p本身 dot_to_circle12345678910Point dot_to_circle(Point c, double r, Point p) &#123; Point u, v; if (dis(p, c) &lt; eps) return p; u.x = c.x + r * fabs(c.x - p.x) / dis(c, p); u.y = c.y + r * fabs(c.y - p.y) / dis(c, p) * ((c.x - p.x) * (c.y - p.y) &lt; 0 ? -1 : 1); v.x = c.x - r * fabs(c.x - p.x) / dis(c, p); v.y = c.y - r * fabs(c.y - p.y) / dis(c, p) * ((c.x - p.x) * (c.y - p.y) &lt; 0 ? -1 : 1); return dis(u, p) &lt; dis(v, p) ? u : v;&#125; 计算直线与圆的交点,保证直线与圆有交点 intersection_line_circle传进来的是直线上两点 123456789101112void intersection_line_circle(Point c, double r, Point l1, Point l2, Point&amp; p1, Point&amp; p2) &#123; Point p = c; double t; p.x += l1.y - l2.y; p.y += l2.x - l1.x; p = Get_line_intersection(p, c - p, l1, l2 - l1); t = sqrt(r * r - dis(p, c) * dis(p, c)) / dis(l1, l2); p1.x = p.x + (l2.x - l1.x) * t; p1.y = p.y + (l2.y - l1.y) * t; p2.x = p.x - (l2.x - l1.x) * t; p2.y = p.y - (l2.y - l1.y) * t;&#125; 计算圆与圆的交点,保证圆与圆有交点,圆心不重合 intersection_circle_circle12345678910void intersection_circle_circle(Point c1, double r1, Point c2, double r2, Point&amp; p1, Point&amp; p2) &#123; Point u, v; double t; t = (1 + (r1 * r1 - r2 * r2) / dis(c1, c2) / dis(c1, c2)) / 2; u.x = c1.x + (c2.x - c1.x) * t; u.y = c1.y + (c2.y - c1.y) * t; v.x = u.x + c1.y - c2.y; v.y = u.y - c1.x + c2.x; intersection_line_circle(c1, r1, u, v, p1, p2);&#125; 求圆外一点对圆(o,r)的两个切点 TangentPoint_PCpoi为圆外的那个点 12345678910111213141516void TangentPoint_PC(Point poi, Point o, double r, Point&amp; result1, Point&amp; result2) &#123; double line = sqrt((poi.x - o.x) * (poi.x - o.x) + (poi.y - o.y) * (poi.y - o.y)); double angle = acos(r / line); Point unitvector, lin; lin.x = poi.x - o.x; lin.y = poi.y - o.y; unitvector.x = lin.x / sqrt(lin.x * lin.x + lin.y * lin.y) * r; unitvector.y = lin.y / sqrt(lin.x * lin.x + lin.y * lin.y) * r; result1 = Rotate(unitvector, -angle); result2 = Rotate(unitvector, angle); result1.x += o.x; result1.y += o.y; result2.x += o.x; result2.y += o.y; return;&#125; 求外接圆 get_circumcircle可以解决三点定圆问题 12345678910Circle get_circumcircle(Point p1, Point p2, Point p3)&#123; double Bx = p2.x - p1.x, By = p2.y - p1.y; double Cx = p3.x - p1.x, Cy = p3.y - p1.y; double D = 2 * (Bx * Cy - By * Cx); double ansx = (Cy * (Bx * Bx + By * By) - By * (Cx * Cx + Cy * Cy)) / D + p1.x; double ansy = (Bx * (Cx * Cx + Cy * Cy) - Cx * (Bx * Bx + By * By)) / D + p1.y; Point p(ansx, ansy); return Circle(p, Length(p1 - p));&#125; 求内切圆 get_incircle12345678Circle get_incircle(Point p1, Point p2, Point p3)&#123; double a = Length(p2 - p3); double b = Length(p3 - p1); double c = Length(p1 - p2); Point p = (p1 * a + p2 * b + p3 * c) / (a + b + c); return Circle(p, Distance_point_to_line(p, p1, p2));&#125; 判断两圆关系 relationcircle5 相离4 外切3 相交2 内切1 内含 12345678910int relationcircle(Circle v, Circle p) &#123; double d = dis(p.c, v.c); if (sgn(d - p.r - v.r) &gt; 0)return 5; if (sgn(d - p.r - v.r) == 0)return 4; double l = fabs(p.r - v.r ); if (sgn(d - p.r - v.r) &lt; 0 &amp;&amp; sgn(d - l) &gt; 0)return 3; if (sgn(d - l) == 0)return 2; if (sgn(d - l) &lt; 0)return 1;&#125; 求球面上两个点的最短距离只允许在球面上走，设两个点的距离为d，球半径为r，则距离为2asin(d&#x2F;2r)r 1ans = asin(d / (2 * r)) * r * 2; 最小圆覆盖 min_cover_circlep为点集，n为数量，注意从0开始 123456789101112131415161718192021Circle min_cover_circle(Point p[], int n)&#123; random_shuffle(p, p + n); Circle c = &#123; p[0],0 &#125;; for (int i = 1; i &lt; n; i++) &#123; if (sgn(dis(p[i], c.c) - c.r) &gt; 0) &#123; c = &#123; p[i],0 &#125;; for (int j = 0; j &lt; i; j++) &#123; if (sgn(dis(p[j], c.c) - c.r) &gt; 0) &#123; c.c.x = (p[i].x + p[j].x) / 2; c.c.y = (p[i].y + p[j].y) / 2; c.r = dis(p[j], c.c); for (int k = 0; k &lt; j; k++) &#123; if (sgn(dis(p[k], c.c) - c.r) &gt; 0) c = get_circumcircle(p[i], p[j], p[k]); &#125; &#125; &#125; &#125; &#125; return c;&#125; 圆的面积并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 1010;const double eps = 1e-8;const double pi = acos(-1);#define x first#define y secondtypedef pair&lt;double, double&gt; PDD;typedef struct node&#123; PDD r; double R;&#125;Circle;Circle a[maxn];PDD q[maxn];int n;int dcmp(double x, double y)&#123; if(fabs(x - y) &lt; eps) return 0; if(x &lt; y) return -1; return 1;&#125;double f(double x) // 所有圆和X = x这条直线交集的长度&#123; int cnt = 0; for(int i = 0; i &lt; n; i ++)&#123; auto X = fabs(a[i].r.x - x), R = a[i].R; if(dcmp(X, R) &lt; 0)&#123; auto Y = sqrt(R * R - X * X); q[cnt ++] = &#123;a[i].r.y - Y, a[i].r.y + Y&#125;; &#125; &#125; if(!cnt) return 0; sort(q, q + cnt); // 区间合并 double res = 0, st = q[0].x, ed = q[0].y; for(int i = 1; i &lt; cnt; i ++)&#123; if(q[i].x &lt;= ed) ed = max(ed, q[i].y); else&#123; res += ed - st; st = q[i].x, ed = q[i].y; &#125; &#125; res += ed - st; return res;&#125;double simpson(double l, double r)&#123; auto mid = (l + r) / 2; return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;&#125;double asr(double l, double r, double s)&#123; double mid = (l + r) / 2; auto left = simpson(l, mid), right = simpson(mid, r); if(fabs(left + right - s) &lt; eps) return left + right; return asr(l, mid, left) + asr(mid, r, right);&#125;double get_area()&#123; cin &gt;&gt; n; double l = 2000, r = -2000; // 积分范围，根据题意来定 for(int i = 0; i &lt; n; i ++)&#123; cin &gt;&gt; a[i].r.x &gt;&gt; a[i].r.y &gt;&gt; a[i].R; l = min(l, a[i].r.x - a[i].R), r = max(r, a[i].r.x + a[i].R); &#125; printf(&quot;%.3lf\\n&quot;, asr(l - 100, r + 100, simpson(l, r)));&#125; 圆和多边形的面积并1234567891011121314151617181920212223242526272829// 求任意多边形和圆形面积交集的面积// 利用三角剖分，将圆心和每条边的两个点连线，每次求三角形和原型交集的面积，累加求和即可。// 要进行五种情况的分类讨论// 求三角形oab和圆面积交集的面积，圆心处于原点PDD r;double R;double get_circle_triangle_area(PDD a, PDD b)&#123; auto da = get_dist(r, a), db = get_dist(r, b); if(dcmp(R, da) &gt;= 0 &amp;&amp; dcmp(R, db) &gt;= 0) return a * b / 2; if(!sign(a * b)) return 0; PDD pa, pb; auto min_d = get_line_circle_intersection(a, b, pa, pb); if(dcmp(R, min_d) &lt;= 0) return get_sector(a, b); if(dcmp(R, da) &gt;= 0) return get_sector(pb, b) + a * pb / 2; if(dcmp(R, db) &gt;= 0) return get_sector(a, pa) + pa * b / 2; return get_sector(a, pa) + pa * pb / 2 + get_sector(pb, b);&#125;// 求面积，时间复杂度O(n)double work()&#123; double res = 0; for(int i = 0; i &lt; n; i ++)&#123; res += get_circle_triangle_area(q[i], q[(i + 1) % n]); &#125; return fabs(res);&#125; 常用二维计算几何凸包 ConvexHull12345678910111213141516int ConvexHull(Point* p, int n, Point* ch)&#123; sort(p, p + n); int m = 0; for (int i = 0; i &lt; n; ++i) &#123;//下凸包 while (m &gt; 1 &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0)m--; ch[m++] = p[i]; &#125; int k = m; for (int i = n - 2; i &gt;= 0; --i) &#123;//上凸包 while (m &gt; k &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0)m--; ch[m++] = p[i]; &#125; if (n &gt; 1) m--; return m;&#125; 判断点是否在凸包内123456789101112131415161718192021bool inHull(Point A, int n, Point ch[])&#123; int l = 0; int r = n - 1; while (r - l &gt; 1) &#123; int mid = ((r - l) &gt;&gt; 1) + l; double a1 = Cross(ch[mid] - ch[0], A - ch[0]); double a2 = Cross(ch[mid + 1] - ch[0], A - ch[0]); if (sgn(a1) &gt;= 0 &amp;&amp; sgn(a2) &lt;= 0) &#123; if (sgn(Cross(ch[mid + 1] - ch[mid], A - ch[mid])) &gt;= 0) return true; return false; &#125; else if (sgn(a1) &lt; 0) &#123; r = mid; &#125; else &#123; l = mid; &#125; &#125; return false;&#125; 旋转卡壳 Rotating_calipers123456789101112Point p[N], con[N];int n;//凸包返回的点数double Rotating_calipers()&#123; int op = 1; double ans = 0; for (int i = 0; i &lt; n; ++i) &#123; while (H(A[i], A[i + 1], A[p % n + 1]) &gt;= H(A[i], A[i + 1], A[p])) p = (p + 1) % n; //H()为所求的接踵点对条件的计算，这里只卡了一个点可以卡多个点，后续根据实际题目写代码 &#125; return ans;&#125; 求凸包直径 12345678910111213Point p[N], con[N];int con_num;//凸包返回的点数double Rotating_calipers()&#123; int op = 1; double ans = 0; for (int i = 0; i &lt; con_num; ++i) &#123; while (Cross((con[i] - con[op]), (con[i + 1] - con[i])) &lt; Cross((con[i] - con[op + 1]), (con[i + 1] - con[i]))) op = (op + 1) % con_num; ans = max(ans, max(dis(con[i], con[op]), dis(con[i + 1], con[op]))); &#125; return ans;&#125; 最小矩形覆盖12345678910111213141516171819202122232425262728293031323334//计算ac在ab上的投影长度double project(Vector a, Vector b, Vector c)&#123; return Dot(b - a, c - a) / Length(b - a);&#125;void ac(int n, Point *p, Point *rec, double &amp;ans)&#123; for (int i = 0, a = 2, b = 1, c = 2; i &lt; n; i++) &#123; auto d = p[i], e = p[i + 1]; while (sgn(Area2(d, e, p[a]) - Area2(d, e, p[a + 1])) &lt; 0) a = (a + 1) % n; while (sgn(project(d, e, p[b]) - project(d, e, p[b + 1])) &lt; 0) b = (b + 1) % n; if (!i) c = a; while (sgn(project(d, e, p[c]) - project(d, e, p[c + 1])) &gt; 0) c = (c + 1) % n; auto x = p[a], y = p[b], z = p[c]; auto h = Area2(d, e, x) / Length(e - d); auto w = Dot(y - z, e - d) / Length(e - d); if (h * w &lt; ans) &#123; ans = h * w; rec[0] = d + (e - d) / Length(e - d) * project(d, e, y); rec[3] = d + (e - d) / Length(e - d) * project(d, e, z); auto u = Normal(e - d); rec[1] = rec[0] + u * h; rec[2] = rec[3] + u * h; &#125; &#125;&#125;/* printf(&quot;%.5Lf\\n&quot;, ans);//ans为面积 for (int i = 0; i &lt; 4; i++) &#123; if (sgn(rec[i].x) == 0) rec[i].x = 0; if (sgn(rec[i].y) == 0) rec[i].y = 0; printf(&quot;%.5Lf %.5Lf\\n&quot;, rec[i].x, rec[i].y); &#125;*/ 闵可夫斯基和12345678910111213Vector V1[N], V2[N];inline int Mincowski(Point *P1, int n, Point *P2, int m, Vector *V)&#123; // 【闵可夫斯基和】求两个凸包&#123;P1&#125;, &#123;P2&#125;的向量集合&#123;V&#125; = &#123;P1 + P2&#125;构成的凸包 for (int i = 0; i &lt; n; ++i) V1[i] = P1[(i + 1) % n] - P1[i]; for (int i = 0; i &lt; m; ++i) V2[i] = P2[(i + 1) % m] - P2[i]; int t = 0, i = 0, j = 0; V[t++] = P1[0] + P2[0]; while (i &lt; n &amp;&amp; j &lt; m) V[t++] = V[t - 1] + (sgn(Cross(V1[i], V2[j])) &gt; 0 ? V1[i++] : V2[j++]); while (i &lt; n) V[t++] = V[t - 1] + V1[i++]; while (j &lt; m) V[t++] = V[t - 1] + V2[j++]; return t;&#125; 半平面交最好使用scanf和printf进行输入输出 所用直线（有向） 12345678910111213141516//切记使用方法，半平面交为向量左侧，向Line中赋值时需要使用Line结构体/*Line L[100];L[i]=Line(a,a-b);//前一个为点，后一个为向量，向量方向为箭头坐标减去箭尾坐标*/struct Line &#123; Point P; Vector v; double deg; Line() &#123;&#125; Line(Point P, Vector v) :P(P), v(v) &#123; deg = atan2(v.y, v.x); &#125; bool operator &lt; (const Line&amp; L)const &#123; return deg &lt; L.deg; &#125;&#125;;//注意这里的Line定义不同于基础函数中Line的定义使用时需删除基础定义 123456789101112131415161718192021222324252627282930313233bool on_left(Line L, Point P) &#123;//注意题目是否包含等号 return sgn(Cross(L.v, P - L.P)) &gt;= 0;&#125;Point get_intersection(Line a, Line b)&#123; Vector u = a.P - b.P; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.P + a.v * t;&#125;int half_plane_intersection(Line* L, int n, Point* poly)&#123; sort(L, L + n); int first, last; Point* p = new Point[n]; Line* q = new Line[n]; q[first = last = 0] = L[0]; for (int i = 1; i &lt; n; ++i) &#123; while (first &lt; last &amp;&amp; !on_left(L[i], p[last - 1]))last--; while (first &lt; last &amp;&amp; !on_left(L[i], p[first]))first++; q[++last] = L[i]; if (fabs(Cross(q[last].v, q[last - 1].v)) &lt; eps) &#123; last--; if (on_left(q[last], L[i].P))q[last] = L[i]; &#125; if (first &lt; last)p[last - 1] = get_intersection(q[last - 1], q[last]); &#125; while (first &lt; last &amp;&amp; !on_left(q[first], p[last - 1]))last--; if (last - first &lt;= 1)return 0; p[last] = get_intersection(q[last], q[first]); int m = 0; for (int i = first; i &lt;= last; ++i)poly[m++] = p[i]; return m;&#125; 二分半平面交 eg：给出一个凸多边形海岛求，海岛上距离海最远的距离 进行二分半平面交，二分对象为是否有这个点到各个边的距离是mid，二分半平面需要额外使用Normal函数求法向量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct Line &#123; Point P; Vector v; double deg; Line() &#123;&#125; Line(Point P, Vector v) :P(P), v(v) &#123; deg = atan2(v.y, v.x); &#125; bool operator &lt; (const Line&amp; L)const &#123; return deg &lt; L.deg; &#125;&#125;;bool on_left(Line L, Point P) &#123; return Cross(L.v, P - L.P) &gt; 0; &#125;Point get_intersection(Line a, Line b)&#123; Vector u = a.P - b.P; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.P + a.v * t;&#125;int half_plane_intersection(Line* L, int n, Point* poly)&#123; sort(L, L + n); int first, last; Point* p = new Point[n]; Line* q = new Line[n]; q[first = last = 0] = L[0]; for (int i = 1; i &lt; n; ++i) &#123; while (first &lt; last &amp;&amp; !on_left(L[i], p[last - 1]))last--; while (first &lt; last &amp;&amp; !on_left(L[i], p[first]))first++; q[++last] = L[i]; if (fabs(Cross(q[last].v, q[last - 1].v)) &lt; eps) &#123; last--; if (on_left(q[last], L[i].P))q[last] = L[i]; &#125; if (first &lt; last)p[last - 1] = get_intersection(q[last - 1], q[last]); &#125; while (first &lt; last &amp;&amp; !on_left(q[first], p[last - 1]))last--; if (last - first &lt;= 1)return 0; p[last] = get_intersection(q[last], q[first]); int m = 0; for (int i = first; i &lt;= last; ++i)poly[m++] = p[i]; return m;&#125;Line L[N];Point poly[N];Point p[N];Vector v[N], v1[N];int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lf %lf&quot;, &amp;p[i].x, &amp;p[i].y); &#125; p[n] = p[0]; for (int i = 0; i &lt; n; i++) &#123; v[i] = p[i + 1] - p[i]; v1[i] = Normal(v[i]);//单位法向量，即v[i]向左旋转90 &#125; double l = 0, r = 20000; while (r - l &gt; eps) &#123; double mid = l + (r - l) / 2; for (int i = 0; i &lt; n; i++) &#123; L[i] = Line(p[i] + v1[i] * mid, v[i]); &#125; int m = half_plane_intersection(L, n, poly); if (!m) r = mid; else l = mid; &#125; printf(&quot;%.6lf\\n&quot;, l); return 0;&#125; 平面最近点对12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e5 + 5;const double DINF = 1e18;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;Point p[N];int tmp[N], n;bool cmp(const Point &amp;a, const Point &amp;b)&#123; if (a.x == b.x)return a.y &lt; b.y; return a.x &lt; b.x;&#125;bool cmps(const int &amp;a, const int &amp;b)&#123; return p[a].y &lt; p[b].y;&#125;double dis(Point p, Point q)&#123; return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);&#125;Point q[N];double merge(int l, int r)&#123; double d = DINF; if (l == r) return d; int mid = (l + r) / 2; double midx = p[mid].x; d = min(merge(l, mid), merge(mid + 1, r)); int p1 = l, p2 = mid + 1, tot = 0; while (p1 &lt;= mid || p2 &lt;= r) &#123; if (p1 &lt;= mid &amp;&amp; (p2 &gt; r || p[p1].y &lt; p[p2].y)) &#123; q[++tot] = p[p1++]; &#125; else &#123; q[++tot] = p[p2++]; &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; p[l + i - 1] = q[i]; &#125; tot = 0; double dd = d; d = sqrt(dd); for (int i = l; i &lt;= r; i++) &#123; if (abs(p[i].x - midx) &lt;= d) q[++tot] = p[i]; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = i - 1; j &gt;= 1 &amp;&amp; q[i].y - q[j].y &lt;= d; j--) &#123; dd = min(dd, dis(q[i], q[j])); d = sqrt(dd); &#125; &#125; return dd;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y); sort(p + 1, p + 1 + n, cmp); double ans = merge(1, n); printf(&quot;%.0lf\\n&quot;, ans); return 0;&#125; 三角剖分 CulArea123456789101112131415161718192021222324252627282930313233343536373839double CulArea(Point A, Point B, Circle C)&#123; Vector OA = A - C.c, OB = B - C.c; Vector BA = A - B, BC = C.c - B; Vector AB = B - A, AC = C.c - A; double DOA = Length(OA), DOB = Length(OB), DAB = Length(AB), r = C.r; if (sgn(Cross(OA, OB)) == 0) return 0; if (sgn(DOA - C.r) &lt; 0 &amp;&amp; sgn(DOB - C.r) &lt; 0) return Cross(OA, OB) * 0.5; else if (DOB &lt; r &amp;&amp; DOA &gt;= r) &#123; double x = (Dot(BA, BC) + sqrtl(r * r * DAB * DAB - Cross(BA, BC) * Cross(BA, BC))) / DAB; double TS = Cross(OA, OB) * 0.5; return asinl(TS * (1 - x / DAB) * 2 / r / DOA) * r * r * 0.5 + TS * x / DAB; &#125; else if (DOB &gt;= r &amp;&amp; DOA &lt; r) &#123; double y = (Dot(AB, AC) + sqrtl(r * r * DAB * DAB - Cross(AB, AC) * Cross(AB, AC))) / DAB; double TS = Cross(OA, OB) * 0.5; return asinl(TS * (1 - y / DAB) * 2 / r / DOB) * r * r * 0.5 + TS * y / DAB; &#125; else if (fabs(Cross(OA, OB)) &gt;= r * DAB || Dot(AB, AC) &lt;= 0 || Dot(BA, BC) &lt;= 0) &#123; if (Dot(OA, OB) &lt; 0) &#123; if (Cross(OA, OB) &lt; 0) return (-acosl(-1.0) - asinl(Cross(OA, OB) / DOA / DOB)) * r * r * 0.5; else return (acosl(-1.0) - asinl(Cross(OA, OB) / DOA / DOB)) * r * r * 0.5; &#125; else return asinl(Cross(OA, OB) / DOA / DOB) * r * r * 0.5; &#125; else &#123; double x = (Dot(BA, BC) + sqrtl(r * r * DAB * DAB - Cross(BA, BC) * Cross(BA, BC))) / DAB; double y = (Dot(AB, AC) + sqrtl(r * r * DAB * DAB - Cross(AB, AC) * Cross(AB, AC))) / DAB; double TS = Cross(OA, OB) * 0.5; return (asinl(TS * (1 - x / DAB) * 2 / r / DOA) + asinl(TS * (1 - y / DAB) * 2 / r / DOB)) * r * r * 0.5 + TS * ((x + y) / DAB - 1); &#125;&#125;/* double res = 0; for(int i = 0; i &lt; n; i ++)&#123; res += CulArea(p[i], p[(i + 1) % n], C); &#125; cout &lt;&lt; fabs(res) &lt;&lt; endl;*/ 三维计算几何基础函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const double EPS = 0.000001;typedef struct Point3 &#123; double x, y, z; Point3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) &#123;&#125; bool operator == (const Point3&amp; A) const &#123; return x==A.x &amp;&amp; y==A.y &amp;&amp; z==A.z; &#125;&#125;;typedef Point3 Vector3; struct Line3 //空间直线&#123; Point3 a, b;&#125;; struct Plane3 //空间平面&#123; Point3 a, b, c; Plane3() &#123;&#125; Plane3(Point3 a, Point3 b, Point3 c) : a(a), b(b), c(c) &#123; &#125;&#125;; Point3 read_Point3() &#123; double x, y, z; scanf(&quot;%lf%lf%lf&quot;, &amp;x, &amp;y, &amp;z); return Point3(x, y, z);&#125; Vector3 operator + (const Vector3&amp; A, const Vector3&amp; B) &#123; return Vector3(A.x + B.x, A.y + B.y, A.z + B.z);&#125; Vector3 operator - (const Point3&amp; A, const Point3&amp; B) &#123; return Vector3(A.x - B.x, A.y - B.y, A.z - B.z);&#125; Vector3 operator * (const Vector3&amp; A, double p) &#123; return Vector3(A.x * p, A.y * p, A.z * p);&#125; Vector3 operator / (const Vector3&amp; A, double p) &#123; return Vector3(A.x / p, A.y / p, A.z / p);&#125;double Dot(Vector3 A, Vector3 B) &#123; return A.x * B.x + A.y * B.y + A.z * B.z;&#125;double Length(Vector3 A) &#123; return sqrt(Dot(A, A)); &#125;double Angle(Vector3 A, Vector3 B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125;//叉积Vector3 Cross(const Vector3&amp; A, const Vector3&amp; B) &#123; return Vector3(A.y * B.z - A.z * B.y, A.z * B.x - A.x * B.z, A.x * B.y - A.y * B.x);&#125;// 三角形abc面积的两倍double Area2(const Point3&amp; A, const Point3&amp; B, const Point3&amp; C) &#123; return Length(Cross(B - A, C - A));&#125; 矢量差 Subt12345678Point3 Subt( Point3 u, Point3 v )&#123; Point3 ret; ret.x = u.x - v.x; ret.y = u.y - v.y; ret.z = u.z - v.z; return ret;&#125; 平面法向量 NormalVector12345678Point3 NormalVector( Plane3 s )&#123; return Cross( Subt( s.a, s.b ), Subt( s.b, s.c ) );&#125;Point3 NormalVector( Point3 a, Point3 b, Point3 c )&#123; return Cross( Subt( a, b ), Subt( b, c ) );&#125; 两点距离 TwoPointDistance1234double TwoPointDistance( Point3 p1, Point3 p2 )&#123; return sqrt( (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y) + (p1.z - p2.z)*(p1.z - p2.z) );&#125; 点p到平面的距离 DistanceToPlane12345// 点p到平面p0-n的距离。n必须为单位向量double DistanceToPlane(const Point3&amp; p, const Point3&amp; p0, const Vector3&amp; n)&#123; return fabs(Dot(p - p0, n)); // 如果不取绝对值，得到的是有向距离&#125; 点p在平面上的投影 GetPlaneProjection12345// 点p在平面p0-n上的投影。n必须为单位向量(如果不是单位向量就/Length(n)嘛)Point3 GetPlaneProjection(const Point3&amp; p, const Point3&amp; p0, const Vector3&amp; n)&#123; return p - n * Dot(p - p0, n);&#125; 直线与平面的交点 LinePlaneIntersection1234567//直线p1-p2 与平面p0-n的交点Point3 LinePlaneIntersection(Point3 p1, Point3 p2, Point3 p0, Vector3 n)&#123; Vector3 v = p2 - p1; double t = (Dot(n, p0 - p1) / Dot(n, p2 - p1)); //分母为0，直线与平面平行或在平面上 return p1 + v * t; //如果是线段 判断t是否在0~1之间&#125; 空间直线距离 LineToLine123456//空间直线距离,tmp为两直线的公共法向量double LineToLine(Line3 u, Line3 v, Point3&amp; tmp)&#123; tmp = Cross(Subt(u.a, u.b), Subt(v.a, v.b)); return fabs(Dot(Subt(u.a, v.a), tmp)) / Length(tmp);&#125; 点到直线的距离 DistanceToLine点p到平面AB距离 12345double DistanceToLine(const Point3&amp; P, const Point3&amp; A, const Point3&amp; B)&#123; Vector3 v1 = B - A, v2 = P - A; return Length(Cross(v1, v2)) / Length(v1);&#125; 点到线段的距离 DistanceToSegp到AB 1234567891011121314double DistanceToSeg(Point3 p, Point3 a, Point3 b)&#123; if (a == b) return Length(p - a); Vector3 v1 = b - a, v2 = p - a, v3 = p - b; if (Dot(v1, v2) + EPS &lt; 0) return Length(v2); else &#123; if (Dot(v1, v3) - EPS &gt; 0) return Length(v3); else return Length(Cross(v1, v2)) / Length(v1); &#125;&#125; 求异面直线与的公垂线对应的s LineDistance3D12345678910//求异面直线 p1+s*u与p2+t*v的公垂线对应的s 如果平行|重合，返回false,相交truebool LineDistance3D(Point3 p1, Vector3 u, Point3 p2, Vector3 v, double&amp; s)&#123; double b = Dot(u, u) * Dot(v, v) - Dot(u, v) * Dot(u, v); if (abs(b) &lt;= EPS) return false; double a = Dot(u, v) * Dot(v, p1 - p2) - Dot(v, v) * Dot(u, p1 - p2); s = a / b; return true;&#125; p1和p2是否在线段a-b的同侧 SameSide123bool SameSide(const Point3&amp; p1, const Point3&amp; p2, const Point3&amp; a, const Point3&amp; b) &#123; return Dot(Cross(b - a, p1 - a), Cross(b - a, p2 - a)) - EPS &gt;= 0;&#125; 判断点P是否在三角形中 PointInTri123bool PointInTri(const Point3&amp; P, const Point3&amp; P0, const Point3&amp; P1, const Point3&amp; P2) &#123; return SameSide(P, P0, P1, P2) &amp;&amp; SameSide(P, P1, P0, P2) &amp;&amp; SameSide(P, P2, P0, P1);&#125; 判断P是否在三角形A, B, C中，并且到三条边的距离都至少为mindist InsideWithMinDistance123456789101112bool InsideWithMinDistance(const Point3&amp; P, const Point3&amp; A, const Point3&amp; B, const Point3&amp; C, double mindist)&#123; if (!PointInTri(P, A, B, C)) return false; if (DistanceToLine(P, A, B) &lt; mindist) return false; if (DistanceToLine(P, B, C) &lt; mindist) return false; if (DistanceToLine(P, C, A) &lt; mindist) return false; return true;&#125; 判断P是否在凸四边形中，并且到四条边的距离都至少为mindist InsideWithMinDistance凸四边形ABCD（顺时针或逆时针） 12345678910111213141516bool InsideWithMinDistance(const Point3&amp; P, const Point3&amp; A, const Point3&amp; B, const Point3&amp; C, const Point3&amp; D, double mindist)&#123; if (!PointInTri(P, A, B, C)) return false; if (!PointInTri(P, C, D, A)) return false; if (DistanceToLine(P, A, B) &lt; mindist) return false; if (DistanceToLine(P, B, C) &lt; mindist) return false; if (DistanceToLine(P, C, D) &lt; mindist) return false; if (DistanceToLine(P, D, A) &lt; mindist) return false; return true;&#125; 三角形P0、P1、P2是否和线段AB相交 TriSegIntersection12345678910111213141516bool TriSegIntersection(const Point3&amp; P0, const Point3&amp; P1, const Point3&amp; P2, const Point3&amp; A, const Point3&amp; B, Point3&amp; P)&#123; Vector3 n = Cross(P1 - P0, P2 - P0); if (abs(Dot(n, B - A)) &lt;= EPS) return false; // 线段A-B和平面P0P1P2平行或共面 else // 平面A和直线P1-P2有惟一交点 &#123; double t = Dot(n, P0 - A) / Dot(n, B - A); if (t + EPS &lt; 0 || t - 1 - EPS &gt; 0) return false; // 不在线段AB上 P = A + (B - A) * t; // 交点 return PointInTri(P, P0, P1, P2); &#125;&#125; 空间两三角形是否相交 TriTriIntersection12345678910111213bool TriTriIntersection(Point3* T1, Point3* T2)&#123; Point3 P; for (int i = 0; i &lt; 3; i++) &#123; if (TriSegIntersection(T1[0], T1[1], T1[2], T2[i], T2[(i + 1) % 3], P)) return true; if (TriSegIntersection(T2[0], T2[1], T2[2], T1[i], T1[(i + 1) % 3], P)) return true; &#125; return false;&#125; 空间两直线上最近点对 SegSegDistance返回最近距离 123456789101112131415161718double SegSegDistance(Point3 a1, Point3 b1, Point3 a2, Point3 b2, Point3&amp; ans1, Point3&amp; ans2)&#123; Vector3 v1 = (a1 - b1), v2 = (a2 - b2); Vector3 N = Cross(v1, v2); Vector3 ab = (a1 - a2); double ans = Dot(N, ab) / Length(N); Point3 p1 = a1, p2 = a2; Vector3 d1 = b1 - a1, d2 = b2 - a2; double t1, t2; t1 = Dot((Cross(p2 - p1, d2)), Cross(d1, d2)); t2 = Dot((Cross(p2 - p1, d1)), Cross(d1, d2)); double dd = Length((Cross(d1, d2))); t1 /= dd * dd; t2 /= dd * dd; ans1 = (a1 + (b1 - a1) * t1); ans2 = (a2 + (b2 - a2) * t2); return fabs(ans);&#125; ab，ac，ad的混合积&amp;四面体体积 Volume6四面体(三角形体)abcd的有向体积的6倍(六面体(正方形体)的体积) 123double Volume6(const Point3&amp; A, const Point3&amp; B, const Point3&amp; C, const Point3&amp; D) &#123; return Dot(D - A, Cross(B - A, C - A));&#125; 四面体的重心 Centroid123Point3 Centroid(const Point3&amp; A, const Point3&amp; B, const Point3&amp; C, const Point3&amp; D) &#123; return (A + B + C + D) / 4.0;&#125; 凸多面体的重心设vi表示第i个四面体的体积，ai表示重心，则多面体的重心为：$$\\frac{\\sum_{i&#x3D;1}^{n}a_{i}\\times v_{i}}{\\sum_{i&#x3D;1}^{n}v_{i}}$$ 球的体积交and并1234567891011121314151617181920212223242526272829303132333435363738double pow2(double x) &#123; return x * x; &#125;double pow3(double x) &#123; return x * x * x; &#125;double dis(Point3 x,Point3 y)&#123; return pow2(x.x - y.x) + pow2(x.y - y.y) + pow2(x.z - y.z);&#125;double cos(double a, double b, double c) &#123; return (b * b + c * c - a * a) / (2 * b * c); &#125; double cap(double r, double h) &#123; return PI * (r * 3 - h) * h * h / 3; &#125; // 2球体积交double sphere_intersect(Point3 x, double r1, Point3 y, double r2)&#123; double d = dis(x, y); // 相离 if (d &gt;= pow2(r1 + r2)) return 0; // 包含 if (d &lt;= pow2(r1 - r2)) return pow3(min(r1, r2)) * 4 * PI / 3; // 相交 double h1 = r1 - r1 * cos(r2, r1, sqrt(d)), h2 = r2 - r2 * cos(r1, r2, sqrt(d)); return cap(r1, h1) + cap(r2, h2);&#125;// 2球体积并double sphere_union(Point3 x, double r1, Point3 y, double r2)&#123; double d = dis(x, y); // 相离 if (d &gt;= pow2(r1 + r2)) return (pow3(r1) + pow3(r2)) * 4 * PI / 3; // 包含 if (d &lt;= pow2(r1 - r2)) return pow3(max(r1, r2)) * 4 * PI / 3; // 相交 double h1 = r1 + r1 * cos(r2, r1, sqrt(d)), h2 = r2 + r2 * cos(r1, r2, sqrt(d)); return cap(r1, h1) + cap(r2, h2);&#125; 三维凸包凸多面体 ConvexPolyhedron12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct ConvexPolyhedron &#123; int n; vector&lt;Point3&gt; P, P2; vector&lt;Face&gt; faces; bool read() &#123; if (scanf(&quot;%d&quot;, &amp;n) != 1) &#123; return false; &#125; P.resize(n); P2.resize(n); for (int i = 0; i &lt; n; i++) &#123; P[i] = read_Point3(); P2[i] = add_noise(P[i]); &#125; faces = CH3D(P2); return true; &#125; //三维凸包重心 Point3 centroid() &#123; Point3 C = P[0]; double totv = 0; Point3 tot(0, 0, 0); for (int i = 0; i &lt; faces.size(); i++) &#123; Point3 p1 = P[faces[i].v[0]], p2 = P[faces[i].v[1]], p3 = P[faces[i].v[2]]; double v = -Volume6(p1, p2, p3, C); totv += v; tot = tot + Centroid(p1, p2, p3, C) * v; &#125; return tot / totv; &#125; //凸包重心到表面最近距离 double mindist(Point3 C) &#123; double ans = 1e30; for (int i = 0; i &lt; faces.size(); i++) &#123; Point3 p1 = P[faces[i].v[0]], p2 = P[faces[i].v[1]], p3 = P[faces[i].v[2]]; ans = min(ans, fabs(-Volume6(p1, p2, p3, C) / Area2(p1, p2, p3))); &#125; return ans; &#125;&#125;; 凸包的定义 Face123456789101112131415161718struct Face &#123; int v[3]; Face(int a, int b, int c) &#123; v[0] = a; v[1] = b; v[2] = c; &#125;//逆时针旋转 Vector3 Normal(const vector&lt;Point3&gt;&amp; P) const &#123; return Cross(P[v[1]] - P[v[0]], P[v[2]] - P[v[0]]); &#125; // f是否能看见P[i] int CanSee(const vector&lt;Point3&gt;&amp; P, int i) const &#123; return Dot(P[i] - P[v[0]], Normal(P)) &gt; 0; &#125;&#125;; 加干扰防止多点共面 add_noise123456789101112double rand01()&#123; return rand() / (double)RAND_MAX;&#125;double randeps()&#123; return (rand01() - 0.5) * EPS;&#125;Point3 add_noise(const Point3&amp; p)&#123; return Point3(p.x + randeps(), p.y + randeps(), p.z + randeps());&#125; 增量法求三维凸包 CH3D12345678910111213141516171819202122232425262728293031323334353637383940414243// 注意：没有考虑各种特殊情况（如四点共面）。实践中，请在调用前对输入点进行微小扰动//vector&lt;Face&gt;CH3D(Point_3D* p, int n)//所有面的点集和点数vector&lt;Face&gt; CH3D(const vector&lt;Point3&gt;&amp; P)&#123; int n = P.size(); vector&lt;vector&lt;int&gt; &gt; vis(n); for (int i = 0; i &lt; n; i++) &#123; vis[i].resize(n); &#125; vector&lt;Face&gt; cur; cur.push_back(Face(0, 1, 2)); // 由于已经进行扰动，前三个点不共线 cur.push_back(Face(2, 1, 0)); for (int i = 3; i &lt; n; i++) &#123; vector&lt;Face&gt; next; for (int j = 0; j &lt; cur.size(); j++) &#123; Face&amp; f = cur[j]; int res = f.CanSee(P, i); if (!res) &#123; next.push_back(f); &#125; for (int k = 0; k &lt; 3; k++) &#123; vis[f.v[k]][f.v[(k + 1) % 3]] = res; &#125; &#125; for (int j = 0; j &lt; cur.size(); j++) for (int k = 0; k &lt; 3; k++) &#123; int a = cur[j].v[k], b = cur[j].v[(k + 1) % 3]; if (vis[a][b] != vis[b][a] &amp;&amp; vis[a][b]) // (a,b)是分界线，左边对P[i]可见 &#123; next.push_back(Face(a, b, i)); &#125; &#125; cur = next; &#125; return cur;&#125; 三维凸包模板合集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286const int MAXN=550;const double eps=1e-8; struct Point&#123; double x,y,z; Point()&#123;&#125; Point(double xx,double yy,double zz):x(xx),y(yy),z(zz)&#123;&#125; //两向量之差 Point operator -(const Point p1) &#123; return Point(x-p1.x,y-p1.y,z-p1.z); &#125; //两向量之和 Point operator +(const Point p1) &#123; return Point(x+p1.x,y+p1.y,z+p1.z); &#125; //叉乘 Point operator *(const Point p) &#123; return Point(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x); &#125; Point operator *(double d) &#123; return Point(x*d,y*d,z*d); &#125; Point operator / (double d) &#123; return Point(x/d,y/d,z/d); &#125; //点乘 double operator ^(Point p) &#123; return (x*p.x+y*p.y+z*p.z); &#125;&#125;; struct CH3D&#123; struct face &#123; //表示凸包一个面上的三个点的编号 int a,b,c; //表示该面是否属于最终凸包上的面 bool ok; &#125;; //初始顶点数 int n; //初始顶点 Point P[MAXN]; //凸包表面的三角形数 int num; //凸包表面的三角形 face F[8*MAXN]; //凸包表面的三角形 int g[MAXN][MAXN]; //向量长度 double vlen(Point a) &#123; return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); &#125; //叉乘 Point cross(const Point &amp;a,const Point &amp;b,const Point &amp;c) &#123; return Point((b.y-a.y)*(c.z-a.z)-(b.z-a.z)*(c.y-a.y), (b.z-a.z)*(c.x-a.x)-(b.x-a.x)*(c.z-a.z), (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x) ); &#125; //三角形面积*2 double area(Point a,Point b,Point c) &#123; return vlen((b-a)*(c-a)); &#125; //四面体有向体积*6 double volume(Point a,Point b,Point c,Point d) &#123; return (b-a)*(c-a)^(d-a); &#125; //正：点在面同向 double dblcmp(Point &amp;p,face &amp;f) &#123; Point m=P[f.b]-P[f.a]; Point n=P[f.c]-P[f.a]; Point t=p-P[f.a]; return (m*n)^t; &#125; void deal(int p,int a,int b) &#123; int f=g[a][b];//搜索与该边相邻的另一个平面 face add; if(F[f].ok) &#123; if(dblcmp(P[p],F[f])&gt;eps) dfs(p,f); else &#123; add.a=b; add.b=a; add.c=p;//这里注意顺序，要成右手系 add.ok=true; g[p][b]=g[a][p]=g[b][a]=num; F[num++]=add; &#125; &#125; &#125; void dfs(int p,int now)//递归搜索所有应该从凸包内删除的面 &#123; F[now].ok=0; deal(p,F[now].b,F[now].a); deal(p,F[now].c,F[now].b); deal(p,F[now].a,F[now].c); &#125; bool same(int s,int t) &#123; Point &amp;a=P[F[s].a]; Point &amp;b=P[F[s].b]; Point &amp;c=P[F[s].c]; return fabs(volume(a,b,c,P[F[t].a]))&lt;eps &amp;&amp; fabs(volume(a,b,c,P[F[t].b]))&lt;eps &amp;&amp; fabs(volume(a,b,c,P[F[t].c]))&lt;eps; &#125; //构建三维凸包 void create() &#123; int i,j,tmp; face add; num=0; if(n&lt;4)return; //********************************************** //此段是为了保证前四个点不共面 bool flag=true; for(i=1;i&lt;n;i++) &#123; if(vlen(P[0]-P[i])&gt;eps) &#123; swap(P[1],P[i]); flag=false; break; &#125; &#125; if(flag)return; flag=true; //使前三个点不共线 for(i=2;i&lt;n;i++) &#123; if(vlen((P[0]-P[1])*(P[1]-P[i]))&gt;eps) &#123; swap(P[2],P[i]); flag=false; break; &#125; &#125; if(flag)return; flag=true; //使前四个点不共面 for(int i=3;i&lt;n;i++) &#123; if(fabs((P[0]-P[1])*(P[1]-P[2])^(P[0]-P[i]))&gt;eps) &#123; swap(P[3],P[i]); flag=false; break; &#125; &#125; if(flag)return; //***************************************** for(i=0;i&lt;4;i++) &#123; add.a=(i+1)%4; add.b=(i+2)%4; add.c=(i+3)%4; add.ok=true; if(dblcmp(P[i],add)&gt;0)swap(add.b,add.c); g[add.a][add.b]=g[add.b][add.c]=g[add.c][add.a]=num; F[num++]=add; &#125; for(i=4;i&lt;n;i++) &#123; for(j=0;j&lt;num;j++) &#123; if(F[j].ok&amp;&amp;dblcmp(P[i],F[j])&gt;eps) &#123; dfs(i,j); break; &#125; &#125; &#125; tmp=num; for(i=num=0;i&lt;tmp;i++) if(F[i].ok) F[num++]=F[i]; &#125; //表面积 double area() &#123; double res=0; if(n==3) &#123; Point p=cross(P[0],P[1],P[2]); res=vlen(p)/2.0; return res; &#125; for(int i=0;i&lt;num;i++) res+=area(P[F[i].a],P[F[i].b],P[F[i].c]); return res/2.0; &#125; double volume() &#123; double res=0; Point tmp(0,0,0); for(int i=0;i&lt;num;i++) res+=volume(tmp,P[F[i].a],P[F[i].b],P[F[i].c]); return fabs(res/6.0); &#125; //表面三角形个数 int triangle() &#123; return num; &#125; //表面多边形个数 int polygon() &#123; int i,j,res,flag; for(i=res=0;i&lt;num;i++) &#123; flag=1; for(j=0;j&lt;i;j++) if(same(i,j)) &#123; flag=0; break; &#125; res+=flag; &#125; return res; &#125; //三维凸包重心 Point barycenter() &#123; Point ans(0,0,0),o(0,0,0); double all=0; for(int i=0;i&lt;num;i++) &#123; double vol=volume(o,P[F[i].a],P[F[i].b],P[F[i].c]); ans=ans+(o+P[F[i].a]+P[F[i].b]+P[F[i].c])/4.0*vol; all+=vol; &#125; ans=ans/all; return ans; &#125; //点到面的距离 double ptoface(Point p,int i) &#123; return fabs(volume(P[F[i].a],P[F[i].b],P[F[i].c],p)/vlen((P[F[i].b]-P[F[i].a])*(P[F[i].c]-P[F[i].a]))); &#125;&#125;;CH3D hull;int main()&#123; while(scanf(&quot;%d&quot;,&amp;hull.n)==1) &#123; for(int i=0;i&lt;hull.n;i++) &#123; scanf(&quot;%lf%lf%lf&quot;,&amp;hull.P[i].x,&amp;hull.P[i].y,&amp;hull.P[i].z); &#125; hull.create(); Point p=hull.barycenter();//求重心 double ans1=1e20; for(int i=0;i&lt;hull.num;i++) &#123; ans1=min(ans1,hull.ptoface(p,i)); &#125; printf(&quot;%.3f\\n&quot;,ans1); &#125; return 0;&#125; 调试对拍12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;void init()&#123; srand(time(0)); ofstream fout(&quot;input.txt&quot;); fout.close();&#125;int main()&#123; for (int i = 0;; i++) &#123; cout &lt;&lt; &quot;test: &quot; &lt;&lt; i &lt;&lt; endl; init(); system(&quot;t.exe &lt;input.txt&gt; tout.txt&quot;); system(&quot;p.exe &lt;input.txt&gt; pout.txt&quot;); if (system(&quot;fc tout.txt pout.txt&quot;)) &#123; puts(&quot;WA!!&quot;); break; &#125; &#125;&#125; 输出运行时间12345678clock_t start_time, end_time;start_time = clock();//coderend_time = clock();cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; (double) (end_time - start_time) / CLOCKS_PER_SEC &lt;&lt; &quot;s&quot; &lt;&lt; endl; 输入输出到文件12freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); cmake配置123456789cmake_minimum_required(VERSION 3.29)project(geometry)set(CMAKE_CXX_STANDARD 17)# 有什么文件就在后面加什么，这里还有tt.cppadd_executable(geometry main.cpp tt.cpp)target_compile_definitions(geometry PRIVATE -Dstavage)","path":"2024/11/08/算法/","date":"11-08","excerpt":"","tags":[{"name":"模板","slug":"模板","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"我的第一次博客","text":"","path":"2024/11/08/我的第一次博客/","date":"11-08","excerpt":"","tags":[{"name":"Tset","slug":"Tset","permalink":"http://example.com/tags/Tset/"}]}],"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"后端常用","slug":"后端常用","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8/"},{"name":"介绍","slug":"介绍","permalink":"http://example.com/tags/%E4%BB%8B%E7%BB%8D/"},{"name":"模板","slug":"模板","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"Tset","slug":"Tset","permalink":"http://example.com/tags/Tset/"}]}